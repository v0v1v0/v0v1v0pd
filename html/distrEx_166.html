<div class="container">

<table style="width: 100%;"><tr>
<td>distrExOptions</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to change the global variables of the package ‘distrEx’ </h2>

<h3>Description</h3>

<p>With <code>distrExOptions</code> you can inspect and change 
the global variables of the package <span class="pkg">distrEx</span>. </p>


<h3>Usage</h3>

<pre><code class="language-R">distrExOptions(...)
distrExoptions(...)
getdistrExOption(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> any options can be defined, using name = value or by passing a list of such tagged values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p> a character string holding an option name.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>distrExOptions()</code> returns a list of the global variables.<br><code>distrExOptions(x)</code> returns the global variable <var>x</var>.<br><code>getdistrExOption(x)</code> returns the global variable <var>x</var>.<br><code>distrExOptions(x=y)</code> sets the value of the global variable <var>x</var> to <var>y</var>.
</p>


<h3>distrExoptions</h3>

<p>For compatibility with spelling in package <span class="pkg">distr</span>, <code>distrExoptions</code> is 
just a synonym to <code>distrExOptions</code>.
</p>


<h3>Global Options</h3>


<dl>
<dt>MCIterations:</dt>
<dd>
<p> number of Monte-Carlo iterations used for crude 
Monte-Carlo integration; defaults to <code>1e5</code>. </p>
</dd>
<dt>GLIntegrateTruncQuantile:</dt>
<dd>
<p> If <code>integrate</code> fails and there are 
infinite integration limits, the function <code>GLIntegrate</code> is 
called inside of <code>distrExIntegrate</code> with the corresponding quantiles 
<code>GLIntegrateTruncQuantile</code> respectively,  
1 - <code>GLIntegrateTruncQuantile</code> as finite integration limits; defaults
to <code>10*.Machine$double.eps</code>. </p>
</dd>
<dt>GLIntegrateOrder:</dt>
<dd>
<p> The order used for the Gauss-Legendre integration
inside of <code>distrExIntegrate</code>; defaults to 500. </p>
</dd>
<dt>ElowerTruncQuantile:</dt>
<dd>
<p> The lower limit of integration used inside of 
<code>E</code> which corresponds to the <code>ElowerTruncQuantile</code>-quantile; defaults to
<code>1e-7</code>. </p>
</dd>
<dt>EupperTruncQuantile:</dt>
<dd>
<p> The upper limit of integration used inside of 
<code>E</code> which corresponds to the (1-<code>ElowerTruncQuantile</code>)-quantile; defaults to
<code>1e-7</code>. </p>
</dd>
<dt>ErelativeTolerance:</dt>
<dd>
<p> The relative tolerance used inside of <code>E</code>
when calling <code>distrExIntegrate</code>; defaults to <code>.Machine$double.eps^0.25</code>. </p>
</dd>
<dt>m1dfLowerTruncQuantile:</dt>
<dd>
<p> The lower limit of integration used inside 
of <code>m1df</code> which corresponds to the <code>m1dfLowerTruncQuantile</code>-quantile; defaults to 0. </p>
</dd>
<dt>m1dfRelativeTolerance:</dt>
<dd>
<p> The relative tolerance used inside of <code>m1df</code>
when calling <code>distrExIntegrate</code>; defaults to <code>.Machine$double.eps^0.25</code>. </p>
</dd>
<dt>m2dfLowerTruncQuantile:</dt>
<dd>
<p> The lower limit of integration used inside 
of <code>m2df</code> which corresponds to the <code>m2dfLowerTruncQuantile</code>-quantile;
defaults to 0. </p>
</dd>
<dt>m2dfRelativeTolerance:</dt>
<dd>
<p> The relative tolerance used inside of <code>m2df</code>
when calling <code>distrExIntegrate</code>; defaults to <code>.Machine$double.eps^0.25</code>. </p>
</dd>
<dt>nDiscretize:</dt>
<dd>
<p> number of support values used for the discretization
of objects of class <code>"AbscontDistribution"</code>; defaults to 100. </p>
</dd>
<dt>hSmooth:</dt>
<dd>
<p> smoothing parameter to smooth objects of class 
<code>"DiscreteDistribution"</code>. This is done via convolution with the
normal distribution <code>Norm(mean = 0, sd = hSmooth)</code>; defaults to 0.05.</p>
</dd>
<dt>IQR.fac:</dt>
<dd>
<p>for determining sensible integration ranges, we use
both quantile and scale based methods; for the scale based
method we use the median of the distribution <code class="reqn">\pm</code>
<code>IQR.fac</code><code class="reqn">\times</code> the IQR; defaults to 15.</p>
</dd>
<dt>propagate.names.functionals</dt>
<dd>
<p>should names obtained from parameter
coordinates be propagated to return values of specific S4 methods
for functionals; defaults to <code>TRUE</code>. </p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code>options</code>, <code>getOption</code></p>


<h3>Examples</h3>

<pre><code class="language-R">distrExOptions()
distrExOptions("ElowerTruncQuantile")
distrExOptions("ElowerTruncQuantile" = 1e-6)
# or
distrExOptions(ElowerTruncQuantile = 1e-6)
getdistrExOption("ElowerTruncQuantile")
</code></pre>


</div>