<div class="container">

<table style="width: 100%;"><tr>
<td>model_additive</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Additive DEA model.</h2>

<h3>Description</h3>

<p>Solve the additive model of Charnes et. al (1985). With the current
version of deaR, it is possible to solve input-oriented, output-oriented,
and non-oriented additive model under constant and non-constant returns to scale.
</p>
<p>Besides, the user can set weights for the input slacks and/or output slacks. So,
it is also possible to solve weighted additive models. For example: Measure of
Inefficiency Proportions (MIP), Range Adjusted Measure (RAM), etc.
</p>


<h3>Usage</h3>

<pre><code class="language-R">model_additive(datadea,
               dmu_eval = NULL,
               dmu_ref = NULL,
               orientation = NULL,
               weight_slack_i = 1,
               weight_slack_o = 1,
               rts = c("crs", "vrs", "nirs", "ndrs", "grs"),
               L = 1,
               U = 1,
               compute_target = TRUE,
               returnlp = FALSE,
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>datadea</code></td>
<td>
<p>A <code>deadata</code> object with <code>n</code> DMUs, <code>m</code> inputs and <code>s</code> outputs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmu_eval</code></td>
<td>
<p>A numeric vector containing which DMUs have to be evaluated.
If <code>NULL</code> (default), all DMUs are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmu_ref</code></td>
<td>
<p>A numeric vector containing which DMUs are the evaluation reference set.
If <code>NULL</code> (default), all DMUs are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>This parameter is either <code>NULL</code> (default) or a string, equal to
"io" (input-oriented) or "oo" (output-oriented). It is used to modify the weight slacks. 
If input-oriented, <code>weight_slack_o</code> are taken 0.
If output-oriented, <code>weight_slack_i</code> are taken 0.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_slack_i</code></td>
<td>
<p>A value, vector of length <code>m</code>, or matrix <code>m</code> x
<code>ne</code> (where <code>ne</code> is the length of <code>dmu_eval</code>)
with the weights of the input slacks. If 0, output-oriented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_slack_o</code></td>
<td>
<p>A value, vector of length <code>s</code>, or matrix <code>s</code> x
<code>ne</code> (where <code>ne</code> is the length of <code>dmu_eval</code>)
with the weights of the output slacks. If 0, input-oriented.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rts</code></td>
<td>
<p>A string, determining the type of returns to scale, equal to "crs" (constant),
"vrs" (variable), "nirs" (non-increasing), "ndrs" (non-decreasing) or "grs" (generalized).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Lower bound for the generalized returns to scale (grs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>Upper bound for the generalized returns to scale (grs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute_target</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, it computes targets.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>returnlp</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, it returns the linear problems
(objective function and constraints).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Ignored, for compatibility issues.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>In this model, the efficiency score is the sum of the slacks. Therefore,
a DMU is efficient when the objective value (<code>objval</code>) is zero.
</p>


<h3>Author(s)</h3>

<p><strong>Vicente Coll-Serrano</strong> (<a href="mailto:vicente.coll@uv.es">vicente.coll@uv.es</a>).
<em>Quantitative Methods for Measuring Culture (MC2). Applied Economics.</em>
</p>
<p><strong>Vicente Bolós</strong> (<a href="mailto:vicente.bolos@uv.es">vicente.bolos@uv.es</a>).
<em>Department of Business Mathematics</em>
</p>
<p><strong>Rafael Benítez</strong> (<a href="mailto:rafael.suarez@uv.es">rafael.suarez@uv.es</a>).
<em>Department of Business Mathematics</em>
</p>
<p>University of Valencia (Spain)
</p>


<h3>References</h3>

<p>Charnes, A.; Cooper, W.W.; Golany, B.; Seiford, L.; Stuz, J. (1985) "Foundations
of Data Envelopment Analysis for Pareto-Koopmans Efficient Empirical Production
Functions", Journal of Econometrics, 30(1-2), 91-107.
<a href="https://doi.org/10.1016/0304-4076%2885%2990133-2">doi:10.1016/0304-4076(85)90133-2</a>
</p>
<p>Charnes, A.; Cooper, W.W.; Lewin, A.Y.; Seiford, L.M. (1994). Data Envelopment
Analysis: Theory, Methology, and Application. Boston: Kluwer Academic Publishers.
<a href="https://doi.org/10.1007/978-94-011-0637-5">doi:10.1007/978-94-011-0637-5</a>
</p>
<p>Cooper, W.W.; Park, K.S.; Pastor, J.T. (1999). "RAM: A Range Adjusted Measure
of Inefficiencies for Use with Additive Models, and Relations to Other Models
and Measures in DEA". Journal of Productivity Analysis, 11, p. 5-42.
<a href="https://doi.org/10.1023/A%3A1007701304281">doi:10.1023/A:1007701304281</a>
</p>


<h3>See Also</h3>

<p><code>model_addsupereff</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1. 
# Replication of results in Charnes et. al (1994, p. 27)
x &lt;- c(2, 3, 6, 9, 5, 4, 10) 
y &lt;- c(2, 5, 7, 8, 3, 1, 7)
data_example &lt;- data.frame(dmus = letters[1:7], x, y)
data_example &lt;- make_deadata(data_example, 
                             ni = 1, 
                             no = 1)
result &lt;- model_additive(data_example, 
                         rts = "vrs")
efficiencies(result)
slacks(result)
lambdas(result)

# Example 2.
# Measure of Inefficiency Proportions (MIP).
x &lt;- c(2, 3, 6, 9, 5, 4, 10) 
y &lt;- c(2, 5, 7, 8, 3, 1, 7)
data_example &lt;- data.frame(dmus = letters[1:7], x, y)
data_example &lt;- make_deadata(data_example,
                             ni = 1,
                             no = 1)
result2 &lt;- model_additive(data_example,
                          rts = "vrs",
                          weight_slack_i = 1 / data_example[["input"]],
                          weight_slack_o = 1 / data_example[["output"]])
slacks(result2)

# Example 3.
# Range Adjusted Measure of Inefficiencies (RAM).
x &lt;- c(2, 3, 6, 9, 5, 4, 10) 
y &lt;- c(2, 5, 7, 8, 3, 1, 7)
data_example &lt;- data.frame(dmus = letters[1:7], x, y)
data_example &lt;- make_deadata(data_example,
                             ni = 1,
                             no = 1)
range_i &lt;- apply(data_example[["input"]], 1, max) -
           apply(data_example[["input"]], 1, min)
range_o &lt;- apply(data_example[["output"]], 1, max) -
           apply(data_example[["output"]], 1, min)
w_range_i &lt;- 1 / (range_i * (dim(data_example[["input"]])[1] +
                             dim(data_example[["output"]])[1]))
w_range_o &lt;- 1 / (range_o * (dim(data_example[["input"]])[1] +
                             dim(data_example[["output"]])[1]))
result3 &lt;- model_additive(data_example,
                          rts = "vrs",
                          weight_slack_i = w_range_i,
                          weight_slack_o = w_range_o)
slacks(result3)

</code></pre>


</div>