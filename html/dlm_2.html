<div class="container">

<table style="width: 100%;"><tr>
<td>arms</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Function to perform Adaptive Rejection Metropolis Sampling</h2>

<h3>Description</h3>

<p>Generates a sequence of random variables using ARMS. For multivariate densities, 
ARMS is used along randomly selected straight lines through the current point.
</p>


<h3>Usage</h3>

<pre><code class="language-R">arms(y.start, myldens, indFunc, n.sample, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>y.start</code></td>
<td>
<p>initial point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>myldens</code></td>
<td>
<p>univariate or multivariate log target density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>indFunc</code></td>
<td>
<p>indicator function of the convex support of the target density</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.sample</code></td>
<td>
<p>desired sample size</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>parameters passed to <code>myldens</code> and <code>indFunc</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Strictly speaking, the support of the target density must be a bounded convex set. 
When this is not the case, the following tricks usually work.
If the support is not bounded, restrict it to a bounded set having probability 
practically one. 
A workaround, if the support is not convex, is to consider the convex set 
generated by the support 
and define <code>myldens</code> to return <code>log(.Machine$double.xmin)</code> outside
the true support (see the last example.)
</p>
<p>The next point is generated along a randomly selected line through the current
point using arms.
</p>
<p>Make sure the value returned by <code>myldens</code> is never smaller than
<code>log(.Machine$double.xmin)</code>, to avoid divisions by zero.
</p>


<h3>Value</h3>

<p>An <code>n.sample</code> by <code>length(y.start)</code> matrix, whose rows are the 
sampled points.
</p>


<h3>Note</h3>

<p>The function is based on original C code by W. Gilks for the 
univariate case.
</p>


<h3>Author(s)</h3>

<p>Giovanni Petris <a href="mailto:GPetris@uark.edu">GPetris@uark.edu</a></p>


<h3>References</h3>

<p>Gilks, W.R., Best, N.G. and Tan, K.K.C. (1995)
Adaptive rejection Metropolis sampling within Gibbs sampling
(Corr: 97V46 p541-542 with Neal, R.M.), <em>Applied Statistics</em>
<b>44</b>:455â€“472.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#### ==&gt; Warning: running the examples may take a few minutes! &lt;== ####    

set.seed(4521222)
### Univariate densities
## Unif(-r,r) 
y &lt;- arms(runif(1,-1,1), function(x,r) 1, function(x,r) (x&gt;-r)*(x&lt;r), 5000, r=2)
summary(y); hist(y,prob=TRUE,main="Unif(-r,r); r=2")
## Normal(mean,1)
norldens &lt;- function(x,mean) -(x-mean)^2/2 
y &lt;- arms(runif(1,3,17), norldens, function(x,mean) ((x-mean)&gt;-7)*((x-mean)&lt;7),
          5000, mean=10)
summary(y); hist(y,prob=TRUE,main="Gaussian(m,1); m=10")
curve(dnorm(x,mean=10),3,17,add=TRUE)
## Exponential(1)
y &lt;- arms(5, function(x) -x, function(x) (x&gt;0)*(x&lt;70), 5000)
summary(y); hist(y,prob=TRUE,main="Exponential(1)")
curve(exp(-x),0,8,add=TRUE)
## Gamma(4.5,1) 
y &lt;- arms(runif(1,1e-4,20), function(x) 3.5*log(x)-x,
          function(x) (x&gt;1e-4)*(x&lt;20), 5000)
summary(y); hist(y,prob=TRUE,main="Gamma(4.5,1)")
curve(dgamma(x,shape=4.5,scale=1),1e-4,20,add=TRUE)
## Gamma(0.5,1) (this one is not log-concave)
y &lt;- arms(runif(1,1e-8,10), function(x) -0.5*log(x)-x,
          function(x) (x&gt;1e-8)*(x&lt;10), 5000)
summary(y); hist(y,prob=TRUE,main="Gamma(0.5,1)")
curve(dgamma(x,shape=0.5,scale=1),1e-8,10,add=TRUE)
## Beta(.2,.2) (this one neither)
y &lt;- arms(runif(1), function(x) (0.2-1)*log(x)+(0.2-1)*log(1-x),
          function(x) (x&gt;1e-5)*(x&lt;1-1e-5), 5000)
summary(y); hist(y,prob=TRUE,main="Beta(0.2,0.2)")
curve(dbeta(x,0.2,0.2),1e-5,1-1e-5,add=TRUE)
## Triangular
y &lt;- arms(runif(1,-1,1), function(x) log(1-abs(x)), function(x) abs(x)&lt;1, 5000)     
summary(y); hist(y,prob=TRUE,ylim=c(0,1),main="Triangular")
curve(1-abs(x),-1,1,add=TRUE)
## Multimodal examples (Mixture of normals)
lmixnorm &lt;- function(x,weights,means,sds) {
    log(crossprod(weights, exp(-0.5*((x-means)/sds)^2 - log(sds))))
}
y &lt;- arms(0, lmixnorm, function(x,...) (x&gt;(-100))*(x&lt;100), 5000, weights=c(1,3,2),
          means=c(-10,0,10), sds=c(1.5,3,1.5))
summary(y); hist(y,prob=TRUE,main="Mixture of Normals")
curve(colSums(c(1,3,2)/6*dnorm(matrix(x,3,length(x),byrow=TRUE),c(-10,0,10),c(1.5,3,1.5))),
      par("usr")[1], par("usr")[2], add=TRUE)

### Bivariate densities 
## Bivariate standard normal
y &lt;- arms(c(0,2), function(x) -crossprod(x)/2,
          function(x) (min(x)&gt;-5)*(max(x)&lt;5), 500)
plot(y, main="Bivariate standard normal", asp=1)
## Uniform in the unit square
y &lt;- arms(c(0.2,.6), function(x) 1,
          function(x) (min(x)&gt;0)*(max(x)&lt;1), 500)
plot(y, main="Uniform in the unit square", asp=1)
polygon(c(0,1,1,0),c(0,0,1,1))
## Uniform in the circle of radius r
y &lt;- arms(c(0.2,0), function(x,...) 1,
          function(x,r2) sum(x^2)&lt;r2, 500, r2=2^2)
plot(y, main="Uniform in the circle of radius r; r=2", asp=1)
curve(-sqrt(4-x^2), -2, 2, add=TRUE)
curve(sqrt(4-x^2), -2, 2, add=TRUE)
## Uniform on the simplex
simp &lt;- function(x) if ( any(x&lt;0) || (sum(x)&gt;1) ) 0 else 1
y &lt;- arms(c(0.2,0.2), function(x) 1, simp, 500)
plot(y, xlim=c(0,1), ylim=c(0,1), main="Uniform in the simplex", asp=1)
polygon(c(0,1,0), c(0,0,1))
## A bimodal distribution (mixture of normals)
bimodal &lt;- function(x) { log(prod(dnorm(x,mean=3))+prod(dnorm(x,mean=-3))) }
y &lt;- arms(c(-2,2), bimodal, function(x) all(x&gt;(-10))*all(x&lt;(10)), 500)
plot(y, main="Mixture of bivariate Normals", asp=1)

## A bivariate distribution with non-convex support
support &lt;- function(x) {
    return(as.numeric( -1 &lt; x[2] &amp;&amp; x[2] &lt; 1 &amp;&amp;
                      -2 &lt; x[1] &amp;&amp;
                      ( x[1] &lt; 1 || crossprod(x-c(1,0)) &lt; 1 ) ) )
}
Min.log &lt;- log(.Machine$double.xmin) + 10
logf &lt;- function(x) {
    if ( x[1] &lt; 0 ) return(log(1/4))
    else
        if (crossprod(x-c(1,0)) &lt; 1 ) return(log(1/pi))
    return(Min.log)
}
x &lt;- as.matrix(expand.grid(seq(-2.2,2.2,length=40),seq(-1.1,1.1,length=40)))
y &lt;- sapply(1:nrow(x), function(i) support(x[i,]))
plot(x,type='n',asp=1)
points(x[y==1,],pch=1,cex=1,col='green')
z &lt;- arms(c(0,0), logf, support, 1000)
points(z,pch=20,cex=0.5,col='blue')
polygon(c(-2,0,0,-2),c(-1,-1,1,1))
curve(-sqrt(1-(x-1)^2),0,2,add=TRUE)
curve(sqrt(1-(x-1)^2),0,2,add=TRUE)
sum( z[,1] &lt; 0 ) # sampled points in the square
sum( apply(t(z)-c(1,0),2,crossprod) &lt; 1 ) # sampled points in the circle

</code></pre>


</div>