<div class="container">

<table style="width: 100%;"><tr>
<td>Desc</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Describe Data</h2>

<h3>Description</h3>

<p>Produce summaries of various types of variables. Calculate descriptive
statistics for x and use Word as reporting tool for the numeric results and
for descriptive plots.  The appropriate statistics are chosen depending on
the class of x.  The general intention is to simplify the description
process for lazy typers and return a quick, but rich summary.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Desc(x, ..., main = NULL, plotit = NULL, wrd = NULL)

## S3 method for class 'numeric'
Desc(
  x,
  main = NULL,
  maxrows = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'integer'
Desc(
  x,
  main = NULL,
  maxrows = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'factor'
Desc(
  x,
  main = NULL,
  maxrows = NULL,
  ord = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'labelled'
Desc(
  x,
  main = NULL,
  maxrows = NULL,
  ord = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'ordered'
Desc(
  x,
  main = NULL,
  maxrows = NULL,
  ord = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'character'
Desc(
  x,
  main = NULL,
  maxrows = NULL,
  ord = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'ts'
Desc(x, main = NULL, plotit = NULL, sep = NULL, digits = NULL, ...)

## S3 method for class 'logical'
Desc(
  x,
  main = NULL,
  ord = NULL,
  conf.level = 0.95,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'Date'
Desc(
  x,
  main = NULL,
  dprobs = NULL,
  mprobs = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'table'
Desc(
  x,
  main = NULL,
  conf.level = 0.95,
  verbose = 2,
  rfrq = "111",
  margins = c(1, 2),
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## Default S3 method:
Desc(
  x,
  main = NULL,
  maxrows = NULL,
  ord = NULL,
  conf.level = 0.95,
  verbose = 2,
  rfrq = "111",
  margins = c(1, 2),
  dprobs = NULL,
  mprobs = NULL,
  plotit = NULL,
  sep = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'data.frame'
Desc(x, main = NULL, plotit = NULL, enum = TRUE, sep = NULL, ...)

## S3 method for class 'list'
Desc(x, main = NULL, plotit = NULL, enum = TRUE, sep = NULL, ...)

## S3 method for class 'formula'
Desc(
  formula,
  data = parent.frame(),
  subset,
  main = NULL,
  plotit = NULL,
  digits = NULL,
  ...
)

## S3 method for class 'Desc'
print(
  x,
  digits = NULL,
  plotit = NULL,
  nolabel = FALSE,
  sep = NULL,
  nomain = FALSE,
  ...
)

## S3 method for class 'Desc'
plot(x, main = NULL, ...)

## S3 method for class 'palette'
Desc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>the object to be described. This can be a data.frame, a list, a
table or a vector of the classes: numeric, integer, factor, ordered factor,
logical.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
For the internal default method these can include:
</p>

<dl>
<dt><code>p</code></dt>
<dd>
<p>a vector of probabilities of the same length of <code>x</code>.
An error is given if any entry of <code>p</code> is negative.
This argument will be passed on to chisq.test().
Default is <code>rep(1/length(x), length(x))</code>.</p>
</dd>
<dt><code>add_ni</code></dt>
<dd>
<p>logical. Indicates if the group length should be
displayed in the boxplot.</p>
</dd>
<dt><code>smooth</code></dt>
<dd>
<p>character, either "loess" or "smooth.spline" defining
the type of smoother to be used in num ~ num plots. Default is "loess" for
n &lt; 500 and "smooth.spline" otherwise.</p>
</dd>
</dl>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>(character|<code>NULL</code>|<code>NA</code>), the main title(s).
</p>

<ul>
<li>
<p> If <code>NULL</code>, the title will be composed as:
</p>

<ul>
<li>
<p> variable name (class(es)),
</p>
</li>
<li>
<p> resp. number - variable name (class(es)) if the <code>enum</code> option
is set to <code>TRUE.</code>
</p>
</li>
</ul>
</li>
<li>
<p> Use <code>NA</code> if no caption should be printed at all.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plotit</code></td>
<td>
<p>logical. Should a plot be created? The plot type will be
chosen according to the classes of variables (roughly following a
numeric-numeric, numeric-categorical, categorical-categorical logic).
Default can be defined by option <code>plotit</code>, if it does not exist then
it's set to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wrd</code></td>
<td>
<p>the pointer to a running MS Word instance, as created by
<code>GetNewWrd()</code> (for a new one) or by <code>GetCurrWrd()</code> for an existing
one.  All output will then be redirected there. Default is <code>NULL</code>,
which will report all results to the console.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>maxrows</code></td>
<td>
<p>numeric; defines the maximum number of rows in a frequency
table to be reported. For factors with many levels it is often not
interesting to see all of them. Default is set to 12 most frequent ones
(resp. the first ones if <code>ord</code> is set to <code>"levels"</code> or
<code>"names"</code>).
</p>
<p>For a numeric argument x <code>maxrows</code> is the minimum
number of unique values needed for a numeric variable to be treated as
continuous. If left to its default <code>NULL</code>, x will be regarded as
continuous if it has more than 12 single values. In this case the list of
extreme values will be displayed and the frequency table else.
</p>
<p>If <code>maxrows</code> is &lt; 1 it will be interpreted as percentage. In this case
just as many rows, as the <code>maxrows</code> most frequent levels will be
shown. Say, if <code>maxrows</code> is set to <code>0.8</code>, then the number of rows is
fixed so, that the highest cumulative relative frequency is the first one
going beyond 0.8.
</p>
<p>Setting <code>maxrows</code> to <code>Inf</code> will unconditionally report all values
and also produce a plot with type "h" instead of a histogram.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sep</code></td>
<td>
<p>character. The separator for the title. By default a line of
<code>"-"</code> for the current width of the screen <code>(options("width"))</code>
will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>digits</code></td>
<td>
<p>integer. With how many digits should the relative frequencies
be formatted? Default can be set by
DescToolsOptions(digits=x).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ord</code></td>
<td>
<p>character out of <code>"name"</code> (alphabetical order),
<code>"level"</code>, <code>"asc"</code> (by frequencies ascending), <code>"desc"</code> (by
frequencies descending) defining the order for a frequency table as used for
factors, numerics with few unique values and logicals. Factors (and
character vectors) are by default ordered by their descending frequencies,
ordered factors by their natural order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>confidence level of the interval. If set to <code>NA</code> no
confidence interval will be calculated. Default is 0.95.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dprobs, mprobs</code></td>
<td>
<p>a vector with the probabilities for the Chi-Square test
for days, resp. months, when describing a <code>Date</code> variable.  If this is
left to <code>NULL</code> (default) then a uniform distribution will be used for
days and a monthdays distribution in a non leap year (p = c(31/365, 28/365,
31/365, ...)) for the months. <br>
Applies only to <code>Dates</code> and is ignored else.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>integer out of <code>c(2, 1, 3)</code> defining the verbosity of
the reported results. 2 (default) means medium, 1 less and 3 extensive
results. <br>
Applies only to tables and is ignored else.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rfrq</code></td>
<td>
<p>a string with 3 characters, each of them being <code>1</code> or
<code>0</code>, defining which percentages should be reported. The first position
is interpreted as total percentages, the second as row percentages and the
third as column percentages. "<code>011</code>" hence produces a table output with
row and column percentages. If set to <code>NULL</code> <code>rfrq</code> is defined in
dependency of <code>verbose</code> (<code>verbose = 1</code> sets <code>rfrq</code> to
<code>"000"</code> and else to <code>"111"</code>, latter meaning all percentages will
be reported.) <br>
Applies only to tables and is ignored else.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margins</code></td>
<td>
<p>a vector, consisting out of 1 and/or 2. Defines the margin
sums to be included. Row margins are reported if margins is set to 1. Set it
to 2 for column margins and c(1,2) for both. <br>
Default is <code>NULL</code> (none).<br>
Applies only to tables and is ignored else.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>enum</code></td>
<td>
<p>logical, determining if in data.frames and lists a sequential
number should be included in the main title. Default is TRUE. The reason for
this option is, that if a Word report with enumerated headings is created,
the numbers may be redundant or inconsistent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code> gives
the data values and rhs the corresponding groups.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>an optional matrix or data frame containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nolabel</code></td>
<td>
<p>logical, defining if labels (defined as attribute with the
name <code>label</code>, as done by <code>Label</code>) should be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nomain</code></td>
<td>
<p>logical, determines if the main title of the output is printed
or not, default is <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A <strong>2-dimensional table</strong> will be described with it's relative frequencies, a
short summary containing the total cases, the dimensions of the table,
chi-square tests and some association measures as phi-coefficient,
contingency coefficient and Cramer's V. <br>
Tables with higher dimensions  will simply be printed as flat table,
with marginal sums for the first and for the last dimension.
</p>
<p><code>Desc</code> is a <strong>generic function</strong>. It dispatches to one of the methods above
depending on the class of its first argument. Typing <code>?Desc</code> + TAB at the
prompt should present a choice of links: the help pages for each of these
<code>Desc</code> methods (at least if you're using RStudio, which anyway is
recommended). You don't need to use the full name of the method although you
may if you wish; i.e., <code>Desc(x)</code> is idiomatic R but you can bypass method
dispatch by going direct if you wish: <code>Desc.numeric(x)</code>.
</p>
<p>This function produces a rich description of a <strong>factor</strong>, containing length,
number of NAs, number of levels and detailed frequencies of all levels. The
order of the frequency table can be chosen between descending/ascending
frequency, labels or levels. For ordered factors the order default is
<code>"level"</code>. Character vectors are treated as unordered factors Desc.char
converts x to a factor an processes x as factor.<br>
Desc.ordered does nothing more than changing the standard order for the
frequencies to it's intrinsic order, which means order <code>"level"</code>
instead of <code>"desc"</code> in the factor case.
</p>
<p>Description interface for <strong>dates</strong>. We do here what seems reasonable for
describing dates. We start with a short summary about length, number of NAs
and extreme values, before we describe the frequencies of the weekdays and
months, rounded up by a chi-square test.
</p>
<p>A <strong>2-dimensional table</strong> will be described with it's relative frequencies, a
short summary containing the total cases, the dimensions of the table,
chi-square tests and some association measures as phi-coefficient,
contingency coefficient and Cramer's V. <br>
Tables with higher dimensions will simply be printed as flat table,
with marginal sums for the first and for the last dimension.
</p>
<p>Note that <code>NA</code>s cannot be handled by this interface, as tables in general come
in "as.is", say basically as a matrix without any further information about
potentially previously cleared NAs.
</p>
<p>Description of a <strong>dichotomous variable</strong>. This can either be a logical vector,
a factor with two levels or a numeric variable with only two unique values.
The confidence levels for the relative frequencies are calculated by
<code>BinomCI()</code>, method <code>"Wilson"</code> on a confidence level defined
by <code>conf.level</code>. Dichotomous variables can easily be condensed in one
graphical representation. Desc for a set of flags (=dichotomous variables)
calculates the frequencies, a binomial confidence interval and produces a
kind of dotplot with error bars. Motivation for this function is, that
dichotomous variable in general do not contain intense information.
Therefore it makes sense to condense the description of sets of dichotomous
variables.
</p>
<p>The <strong>formula interface</strong> accepts the formula operators <code>+</code>, <code>:</code>,
<code>*</code>, <code>I()</code>, <code>1</code> and evaluates any function. The left hand
side and right hand side of the formula are evaluated the same way. The
variable pairs are processed in dependency of their classes.
</p>
<p><code>Word</code> This function is not thought of being directly run by the end user.
It will normally be called automatically, when a pointer to a Word instance
is passed to the function <code>Desc()</code>.<br>
However <code>DescWrd</code> takes
some more specific arguments concerning the Word output (like <code>font</code> or
<code>fontsize</code>), which can make it necessary to call the function directly.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>length</code></td>
<td>
<p>the length of the vector (n + NAs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>the valid entries (NAs are excluded)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>NAs</code></td>
<td>
<p>number of NAs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unique</code></td>
<td>
<p>number of unique values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>0s</code></td>
<td>
<p>number of zeros</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mean</code></td>
<td>
<p>arithmetic mean</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>MeanSE</code></td>
<td>
<p>standard error of the mean, as calculated by <code>MeanSE()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>quant</code></td>
<td>
<p>a table of quantiles, as calculated by
quantile(x, probs = c(.05,.10,.25,.5,.75,.9,.95), na.rm = TRUE).
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sd</code></td>
<td>
<p>standard deviation</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vcoef</code></td>
<td>
<p>coefficient of variation: <code>mean(x)</code> / <code>sd(x)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mad</code></td>
<td>
<p>median absolute deviation (<code>stats::mad()</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IQR</code></td>
<td>
<p>interquartile range </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skew</code></td>
<td>
<p>skewness, as calculated by <code>Skew()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kurt</code></td>
<td>
<p>kurtosis, as calculated by <code>Kurt()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>highlow</code></td>
<td>
<p>the lowest and the highest values, reported with their
frequencies in brackets, if &gt; 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frq</code></td>
<td>
<p>a data.frame of absolute and  relative frequencies given by
<code>Freq()</code> if <code>maxlevels</code> &gt; unique values in the vector.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Andri Signorell <a href="mailto:andri@signorell.net">andri@signorell.net</a>
</p>


<h3>See Also</h3>

<p><code>base::summary()</code>, <code>base::plot()</code>
</p>
<p>Other Statistical summary functions: 
<code>Abstract()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
opt &lt;- DescToolsOptions()

# implemented classes:
Desc(d.pizza$wrongpizza)               # logical
Desc(d.pizza$driver)                   # factor
Desc(d.pizza$quality)                  # ordered factor
Desc(as.character(d.pizza$driver))     # character
Desc(d.pizza$week)                     # integer
Desc(d.pizza$delivery_min)             # numeric
Desc(d.pizza$date)                     # Date

Desc(d.pizza)

Desc(d.pizza$wrongpizza, main="The wrong pizza delivered", digits=5)

Desc(table(d.pizza$area))                                    # 1-dim table
Desc(table(d.pizza$area, d.pizza$operator))                  # 2-dim table
Desc(table(d.pizza$area, d.pizza$operator, d.pizza$driver))  # n-dim table

# expressions
Desc(log(d.pizza$temperature))
Desc(d.pizza$temperature &gt; 45)

# supported labels
Label(d.pizza$temperature) &lt;- "This is the temperature in degrees Celsius
measured at the time when the pizza is delivered to the client."
Desc(d.pizza$temperature)
# try as well:      Desc(d.pizza$temperature, wrd=GetNewWrd())

z &lt;- Desc(d.pizza$temperature)
print(z, digits=1, plotit=FALSE)
# plot (additional arguments are passed on to the underlying plot function)
plot(z, main="The pizza's temperature in Celsius", args.hist=list(breaks=50))


# formula interface for single variables
Desc(~ uptake + Type, data = CO2, plotit = FALSE)

# bivariate
Desc(price ~ operator, data=d.pizza)                  # numeric ~ factor
Desc(driver ~ operator, data=d.pizza)                 # factor ~ factor
Desc(driver ~ area + operator, data=d.pizza)          # factor ~ several factors
Desc(driver + area ~ operator, data=d.pizza)          # several factors ~ factor
Desc(driver ~ week, data=d.pizza)                     # factor ~ integer

Desc(driver ~ operator, data=d.pizza, rfrq="111")   # alle rel. frequencies
Desc(driver ~ operator, data=d.pizza, rfrq="000",
     verbose=3)                                  # no rel. frequencies

Desc(price ~ delivery_min, data=d.pizza)              # numeric ~ numeric
Desc(price + delivery_min ~ operator + driver + wrongpizza,
     data=d.pizza, digits=c(2,2,2,2,0,3,0,0) )

Desc(week ~ driver, data=d.pizza, digits=c(2,2,2,2,0,3,0,0))   # define digits

Desc(delivery_min + weekday ~ driver, data=d.pizza)


# without defining data-parameter
Desc(d.pizza$delivery_min ~ d.pizza$driver)


# with functions and interactions
Desc(sqrt(price) ~ operator : factor(wrongpizza), data=d.pizza)
Desc(log(price+1) ~ cut(delivery_min, breaks=seq(10,90,10)),
     data=d.pizza, digits=c(2,2,2,2,0,3,0,0))

# response versus all the rest
Desc(driver ~ ., data=d.pizza[, c("temperature","wine_delivered","area","driver")])

# all the rest versus response
Desc(. ~ driver, data=d.pizza[, c("temperature","wine_delivered","area","driver")])

# pairwise Descriptions
p &lt;- CombPairs(c("area","count","operator","driver","temperature","wrongpizza","quality"), )
for(i in 1:nrow(p))
  print(Desc(formula(gettextf("%s ~ %s", p$X1[i], p$X2[i])), data=d.pizza))


# get more flexibility, create the table first
tab &lt;- as.table(apply(HairEyeColor, c(1,2), sum))
tab &lt;- tab[,c("Brown","Hazel","Green","Blue")]

# display only absolute values, row and columnwise percentages
Desc(tab, row.vars=c(3, 1), rfrq="011", plotit=FALSE)

# do the plot by hand, while setting the colours for the mosaics
cols1 &lt;- SetAlpha(c("sienna4", "burlywood", "chartreuse3", "slategray1"), 0.6)
cols2 &lt;- SetAlpha(c("moccasin", "salmon1", "wheat3", "gray32"), 0.8)
plot(Desc(tab), col1=cols1, col2=cols2)

# choose alternative flavours for graphing numeric ~ factor using pipe
# (colors are recyled)
Desc(temperature ~ driver, data = d.pizza) |&gt; plot(type="dens", col=Pal("Tibco"))


# use global format options for presentation
Fmt(abs=as.fmt(digits=0, big.mark=""))
Fmt(per=as.fmt(digits=2, fmt="%"))
Desc(area ~ driver, d.pizza, plotit=FALSE)

Fmt(abs=as.fmt(digits=0, big.mark="'"))
Fmt(per=as.fmt(digits=3, ldigits=0))
Desc(area ~ driver, d.pizza, plotit=FALSE)

# plot arguments can be fixed in detail
z &lt;- Desc(BoxCox(d.pizza$temperature, lambda = 1.5))
plot(z, mar=c(0, 2.1, 4.1, 2.1), args.rug=TRUE, args.hist=list(breaks=50),
     args.dens=list(from=0))

# The default description for count variables can be inappropriate,
# the density curve does not represent the variable well.
set.seed(1972)
x &lt;- rpois(n = 500, lambda = 5)
Desc(x)
# but setting maxrows to Inf gives a better plot
Desc(x, maxrows = Inf)


# Output into word document (Windows-specific example) -----------------------
# by simply setting wrd=GetNewWrd()
## Not run: 

  # create a new word instance and insert title and contents
  wrd &lt;- GetNewWrd(header=TRUE)

  # let's have a subset
  d.sub &lt;- d.pizza[,c("driver", "date", "operator", "price", "wrongpizza")]

  # do just the univariate analysis
  Desc(d.sub, wrd=wrd)

## End(Not run)

DescToolsOptions(opt)


</code></pre>


</div>