<div class="container">

<table style="width: 100%;"><tr>
<td>E</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic Function for the Computation of (Conditional) Expectations</h2>

<h3>Description</h3>

<p>Generic function for the computation of (conditional) expectations.
</p>


<h3>Usage</h3>

<pre><code class="language-R">E(object, fun, cond, ...)

## S4 method for signature 'UnivariateDistribution,missing,missing'
E(object, 
             low = NULL, upp = NULL, Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'UnivariateDistribution,function,missing'
E(object, fun, 
        useApply = TRUE, low = NULL, upp = NULL,
        Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'AbscontDistribution,missing,missing'
E(object, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'AbscontDistribution,function,missing'
E(object, fun, useApply = TRUE,
             low = NULL, upp = NULL, 
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,missing,missing'
E(object, low = NULL, 
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,function,missing'
E(object, fun,
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,missing,ANY'
E(object, cond, low = NULL, 
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'UnivarMixingDistribution,function,ANY'
E(object, fun, cond,
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'DiscreteDistribution,function,missing'
E(object, fun, useApply = TRUE, 
             low = NULL, upp = NULL, ...)

## S4 method for signature 'AffLinDistribution,missing,missing'
E(object, low = NULL, upp = NULL,
             ..., diagnostic = FALSE)

## S4 method for signature 'AffLinUnivarLebDecDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, ..., diagnostic = FALSE)

## S4 method for signature 'MultivariateDistribution,missing,missing'
E(object, 
             Nsim = getdistrExOption("MCIterations"), ...)
## S4 method for signature 'MultivariateDistribution,function,missing'
E(object, fun,
             useApply = TRUE, Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'DiscreteMVDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, ...)

## S4 method for signature 'DiscreteMVDistribution,function,missing'
E(object, fun, 
             useApply = TRUE, ...)

## S4 method for signature 'AbscontCondDistribution,missing,numeric'
E(object, cond,
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)

## S4 method for signature 'DiscreteCondDistribution,missing,numeric'
E(object, cond,
             useApply = TRUE, low = NULL, upp = NULL, ...)

## S4 method for signature 'UnivariateCondDistribution,function,numeric'
E(object, fun, cond, 
              withCond = FALSE, useApply = TRUE, low = NULL, upp = NULL,
              Nsim = getdistrExOption("MCIterations"), ...)

## S4 method for signature 'AbscontCondDistribution,function,numeric'
E(object, fun, cond, 
               withCond = FALSE, useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac")
             , ..., diagnostic = FALSE)

## S4 method for signature 'DiscreteCondDistribution,function,numeric'
E(object, fun, cond, 
             withCond = FALSE, useApply = TRUE, low = NULL, upp = NULL,...)

## S4 method for signature 'UnivarLebDecDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )
## S4 method for signature 'UnivarLebDecDistribution,function,missing'
E(object, fun, 
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )
## S4 method for signature 'UnivarLebDecDistribution,missing,ANY'
E(object, cond, low = NULL,
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )
## S4 method for signature 'UnivarLebDecDistribution,function,ANY'
E(object, fun, cond, 
             useApply = TRUE, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"), 
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE )

## S4 method for signature 'AcDcLcDistribution,ANY,ANY'
E(object, fun, cond, low = NULL,
             upp = NULL, rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"), 
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"), 
             IQR.fac = getdistrExOption("IQR.fac"), ..., diagnostic = FALSE)
## S4 method for signature 'CompoundDistribution,missing,missing'
E(object, low = NULL,
             upp = NULL, ..., diagnostic = FALSE)

## S4 method for signature 'Arcsine,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'Beta,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Binom,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Cauchy,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'Cauchy,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol = getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")),
             ..., diagnostic = FALSE)
## S4 method for signature 'Chisq,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Dirac,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'DExp,missing,missing'
E(object, low = NULL, upp = NULL, ..., diagnostic = FALSE)
## S4 method for signature 'Exp,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Fd,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Gammad,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Gammad,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol = getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
## S4 method for signature 'Geom,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)







## S4 method for signature 'Hyper,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Logis,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Lnorm,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Nbinom,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Norm,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)

## S4 method for signature 'Pois,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...)
## S4 method for signature 'Unif,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Td,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Weibull,missing,missing'
E(object, low = NULL, upp = NULL,
             propagate.names=getdistrExOption("propagate.names.functionals"), ...,
             diagnostic = FALSE)
## S4 method for signature 'Weibull,function,missing'
E(object, fun, low = NULL, upp = NULL,
             rel.tol = getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ..., diagnostic = FALSE)
.qtlIntegrate(object, fun, low = NULL, upp = NULL,
             rel.tol= getdistrExOption("ErelativeTolerance"),
             lowerTruncQuantile = getdistrExOption("ElowerTruncQuantile"),
             upperTruncQuantile = getdistrExOption("EupperTruncQuantile"),
             IQR.fac = max(1e4,getdistrExOption("IQR.fac")), ...,
             .withLeftTail = FALSE, .withRightTail = FALSE, diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p> object of class <code>"Distribution"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fun</code></td>
<td>
<p> if missing the (conditional) expectation is computed
else the (conditional) expection of <code>fun</code> is computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cond</code></td>
<td>
<p> if not missing the conditional expectation 
given <code>cond</code> is computed. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Nsim</code></td>
<td>
<p> number of MC simulations used to determine the expectation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tol</code></td>
<td>
<p>relative tolerance for <code>distrExIntegrate</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low</code></td>
<td>
<p>lower bound of integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upp</code></td>
<td>
<p>upper bound of integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lowerTruncQuantile</code></td>
<td>
<p>lower quantile for quantile based integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upperTruncQuantile</code></td>
<td>
<p>upper quantile for quantile based integration range.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IQR.fac</code></td>
<td>
<p>factor for scale based integration range (i.e.; 
median of the distribution <code class="reqn">\pm</code><code>IQR.fac</code><code class="reqn">\times</code>IQR).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> additional arguments to <code>fun</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useApply</code></td>
<td>
<p> logical: should <code>sapply</code>, respectively <code>apply</code> 
be used to evaluate <code>fun</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withCond</code></td>
<td>
<p> logical: is <code>cond</code> in the argument list of <code>fun</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.withLeftTail</code></td>
<td>
<p> logical: should left tail (falling into quantile range [0,0.02])
be computed separately to enhance accuracy? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.withRightTail</code></td>
<td>
<p> logical: should right tail (falling into quantile range [0.98,1])
be computed separately to enhance accuracy? </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>propagate.names</code></td>
<td>
<p> logical: should names obtained from parameter
coordinates be propagated to return values of specific S4 methods
for functionals; defaults to the value of the respective
<code>distrExoption</code> <code>propagate.names.functionals</code>. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The precision of the computations can be controlled via 
certain global options; cf. <code>distrExOptions</code>. 
Also note that arguments <code>low</code> and <code>upp</code> should be given as
named arguments in order to prevent them to be matched by arguments
<code>fun</code> or <code>cond</code>. Also the result, when arguments 
<code>low</code> or <code>upp</code> is given, is the <em>unconditional value</em> of the
expectation; no conditioning with respect to <code>low &lt;= object &lt;= upp</code>
is done.
</p>
<p>For the Cauchy, the Gamma and Weibull distribution for integration with
missing argument <code>cond</code> but given argument <code>fun</code>, we use
integration on [0,1]  (i.e, via the respective probability transformation).
This done via helper
function <code>.qtlIntegrate</code>, where both arguments <code>.withLeftTail</code>
and <code>.withRightTail</code> are <code>TRUE</code> for the Cauchy and Gamma distributions,
and only <code>.withRightTail</code> ist <code>TRUE</code> for the Weibull distribution.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code>showDiagnostic</code> and
<code>getDiagnostic</code>.
</p>


<h3>Value</h3>

<p>The (conditional) expectation is computed.
</p>


<h3>Methods</h3>


<dl>
<dt>object = "UnivariateDistribution", fun = "missing", cond = "missing":</dt>
<dd> 
<p>expectation of univariate distributions using crude Monte-Carlo integration. </p>
</dd>
<dt>object = "AbscontDistribution", fun = "missing", cond = "missing":</dt>
<dd> 
<p>expectation of absolutely continuous univariate distributions
using <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = "DiscreteDistribution", fun = "missing", cond = "missing":</dt>
<dd>  
<p>expectation of discrete univariate distributions using <code>support</code>
and <code>sum</code>.</p>
</dd>
<dt>object = "MultivariateDistribution", fun = "missing", cond = "missing":</dt>
<dd>
<p>expectation of multivariate distributions using crude Monte-Carlo integration. </p>
</dd>
<dt>object = "DiscreteMVDistribution", fun = "missing", cond = "missing":</dt>
<dd>
<p>expectation of discrete multivariate distributions. The computation is based
on <code>support</code> and <code>sum</code>.</p>
</dd>
<dt>object = "UnivariateDistribution", fun = "missing", cond = "missing":</dt>
<dd> 
<p>expectation of univariate Lebesgue decomposed distributions
by separate calculations for discrete and absolutely continuous part. </p>
</dd>
<dt>object = "AffLinDistribution", fun = "missing", cond = "missing":</dt>
<dd>
<p>expectation of an affine linear transformation <code class="reqn">aX+b</code> as
<code class="reqn">a E[X]+b</code> for <code>X</code> either <code>"DiscreteDistribution"</code>
or <code>"AbscontDistribution"</code>.
</p>
</dd>
<dt>object = "AffLinUnivarLebDecDistribution", fun = "missing", cond = "missing":</dt>
<dd>
<p>expectation of an affine linear transformation <code class="reqn">aX+b</code> as
<code class="reqn">a E[X]+b</code> for <code>X</code> either <code>"UnivarLebDecDistribution"</code>.
</p>
</dd>
<dt>object = "UnivariateDistribution", fun = "function", cond = "missing":</dt>
<dd> 
<p>expectation of <code>fun</code> under univariate distributions using 
crude Monte-Carlo integration. </p>
</dd>
<dt>object = "UnivariateDistribution", fun = "function", cond = "missing":</dt>
<dd> 
<p>expectation of <code>fun</code> under univariate Lebesgue decomposed distributions
by separate calculations for discrete and absolutely continuous part. </p>
</dd>
<dt>object = "AbscontDistribution", fun = "function", cond = "missing":</dt>
<dd> 
<p>expectation of <code>fun</code> under absolutely continuous 
univariate distributions using <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = "DiscreteDistribution", fun = "function", cond = "missing":</dt>
<dd>  
<p>expectation of <code>fun</code> under discrete univariate 
distributions using <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = "MultivariateDistribution", fun = "function", cond = "missing":</dt>
<dd>
<p>expectation of multivariate distributions using crude Monte-Carlo integration. </p>
</dd>
<dt>object = "DiscreteMVDistribution", fun = "function", cond = "missing":</dt>
<dd>
<p>expectation of <code>fun</code> under discrete multivariate 
distributions. The computation is based on <code>support</code> and <code>sum</code>. </p>
</dd>  
<dt>object = "UnivariateCondDistribution", fun = "missing", cond = "numeric":</dt>
<dd>
<p>conditional expectation for univariate conditional distributions given <code>cond</code>. 
The integral is computed using crude Monte-Carlo integration. </p>
</dd>
<dt>object = "AbscontCondDistribution", fun = "missing", cond = "numeric":</dt>
<dd>
<p>conditional expectation for absolutely continuous, univariate 
conditional distributions given <code>cond</code>. The computation
is based on <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = "DiscreteCondDistribution", fun = "missing", cond = "numeric":</dt>
<dd> 
<p>conditional expectation for discrete, univariate conditional 
distributions given <code>cond</code>. The computation is based 
on <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = "UnivariateCondDistribution", fun = "function", cond = "numeric":</dt>
<dd>
<p>conditional expectation of <code>fun</code> under univariate conditional distributions 
given <code>cond</code>. The integral is computed using crude Monte-Carlo integration. </p>
</dd>
<dt>object = "AbscontCondDistribution", fun = "function", cond = "numeric":</dt>
<dd>
<p>conditional expectation of <code>fun</code> under absolutely continuous, 
univariate conditional distributions given <code>cond</code>. The
computation is based on <code>distrExIntegrate</code>. </p>
</dd>
<dt>object = "DiscreteCondDistribution", fun = "function", cond = "numeric":</dt>
<dd> 
<p>conditional expectation of <code>fun</code> under discrete, univariate 
conditional distributions given <code>cond</code>. The computation is
based on <code>support</code> and <code>sum</code>. </p>
</dd>
<dt>object = "UnivarLebDecDistribution", fun = "missing", cond = "missing":</dt>
<dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = "UnivarLebDecDistribution", fun = "function", cond = "missing":</dt>
<dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = "UnivarLebDecDistribution", fun = "missing", cond = "ANY":</dt>
<dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = "UnivarLebDecDistribution", fun = "function", cond = "ANY":</dt>
<dd>
<p>expectation by separate evaluation of expectation of discrete and
abs. continuous part and subsequent weighting.
</p>
</dd>
<dt>object = "UnivarMixingDistribution", fun = "missing", cond = "missing":</dt>
<dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = "UnivarMixingDistribution", fun = "function", cond = "missing":</dt>
<dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = "UnivarMixingDistribution", fun = "missing", cond = "ANY":</dt>
<dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = "UnivarMixingDistribution", fun = "function", cond = "ANY":</dt>
<dd>
<p>expectation is computed component-wise with subsequent weighting acc.
to <code>mixCoeff</code>.</p>
</dd>
<dt>object = "AcDcLcDistribution", fun = "ANY", cond = "ANY":</dt>
<dd>
<p>expectation by first coercing to class <code>"UnivarLebDecDistribution"</code>
and using the corresponding method.
</p>
</dd>
<dt>object = "CompoundDistribution", fun = "missing", cond = "missing":</dt>
<dd>
<p>if we are in i.i.d. situation (i.e., slot <code>SummandsDistr</code> is of
class <code>UnivariateDistribution</code>) the formula 
<code class="reqn">E[N]E[S]</code> for <code class="reqn">N</code> the frequency distribution and
<code class="reqn">S</code> the summand distribution; else we coerce to 
<code>"UnivarLebDecDistribution"</code>.
</p>
</dd>
<dt>object = "Arcsine", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Beta", fun = "missing", cond = "missing":</dt>
<dd> 
<p>for noncentrality 0 exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Binom", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Cauchy", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Chisq", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Dirac", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "DExp", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Exp", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Fd", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Gammad", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Gammad", fun = "function", cond = "missing":</dt>
<dd> 
<p>use integration over the quantile range for numerical integration
via helper function <code>.qtlIntegrate</code>.</p>
</dd>
<dt>object = "Geom", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
</dl>
<dl>
<dt>object = "Hyper", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Logis", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Lnorm", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Nbinom", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Norm", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
</dl>
<dl>
<dt>object = "Pois", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Unif", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Td", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Weibull", fun = "missing", cond = "missing":</dt>
<dd> 
<p>exact evaluation using explicit expressions.</p>
</dd>
<dt>object = "Weibull", fun = "function", cond = "missing":</dt>
<dd>
<p>use integration over the quantile range for numerical integration
via helper function <code>.qtlIntegrate</code>.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a> and Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code>distrExIntegrate</code>, <code>m1df</code>, <code>m2df</code>,
<code>Distribution-class</code></p>


<h3>Examples</h3>

<pre><code class="language-R"># mean of Exp(1) distribution
E &lt;- Exp() 

E(E) ## uses explicit terms
E(as(E,"AbscontDistribution")) ## uses numerical integration
E(as(E,"UnivariateDistribution")) ## uses simulations
E(E, fun = function(x){2*x^2}) ## uses simulations

# the same operator for discrete distributions:
P &lt;- Pois(lambda=2)

E(P) ## uses explicit terms
E(as(P,"DiscreteDistribution")) ## uses sums
E(as(P,"UnivariateDistribution")) ## uses simulations
E(P, fun = function(x){2*x^2}) ## uses simulations


# second moment of N(1,4)
E(Norm(mean=1, sd=2), fun = function(x){x^2})
E(Norm(mean=1, sd=2), fun = function(x){x^2}, useApply = FALSE)

# conditional distribution of a linear model
D1 &lt;- LMCondDistribution(theta = 1) 
E(D1, cond = 1)
E(Norm(mean=1))
E(D1, function(x){x^2}, cond = 1)
E(Norm(mean=1), fun = function(x){x^2})
E(D1, function(x, cond){cond*x^2}, cond = 2, withCond = TRUE, useApply = FALSE)
E(Norm(mean=2), function(x){2*x^2})

E(as(Norm(mean=2),"AbscontDistribution"))
### somewhat less accurate:
E(as(Norm(mean=2),"AbscontDistribution"), 
     lowerTruncQuantil=1e-4,upperTruncQuantil=1e-4, IQR.fac= 4)
### even less accurate:
E(as(Norm(mean=2),"AbscontDistribution"), 
     lowerTruncQuantil=1e-2,upperTruncQuantil=1e-2, IQR.fac= 4)
### no good idea, but just as an example:
E(as(Norm(mean=2),"AbscontDistribution"), 
     lowerTruncQuantil=1e-2,upperTruncQuantil=1e-2, IQR.fac= .1)

### truncation of integration range; see also m1df...
E(Norm(mean=2), low=2,upp=4)

E(Cauchy())
E(Cauchy(),upp=3,low=-2)
# some Lebesgue decomposed distribution 
mymix &lt;- UnivarLebDecDistribution(acPart = Norm(), discretePart = Binom(4,.4),
         acWeight = 0.4)
E(mymix)
</code></pre>


</div>