<div class="container">

<table style="width: 100%;"><tr>
<td>Node</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a <code>data.tree</code> Structure With <code>Nodes</code>
</h2>

<h3>Description</h3>

<p><code>Node</code> is at the very heart of the <code>data.tree</code> package. All trees are constructed
by tying together <code>Node</code> objects.
</p>


<h3>Usage</h3>

<pre><code class="language-R"># n1 &lt;- Node$new("Node 1")
</code></pre>


<h3>Format</h3>

<p>An <code>R6Class</code> generator object
</p>


<h3>Details</h3>

<p>Assemble <code>Node</code> objects into a <code>data.tree</code>
structure and use the traversal methods to set, get, and perform operations on it. Typically, you construct larger tree 
structures by converting from <code>data.frame</code>, <code>list</code>, or other formats.
</p>
<p>Most methods (e.g. <code>node$Sort()</code>) also have a functional form (e.g. <code>Sort(node)</code>)
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>name</code></dt>
<dd>
<p>Gets or sets the name of a <code>Node</code>. For example <code>Node$name &lt;- "Acme"</code>.</p>
</dd>
<dt><code>printFormatters</code></dt>
<dd>
<p>gets or sets the formatters used to print a <code>Node</code>.
Set this as a list to a root node.
The different formatters are h (horizontal), v (vertical), l (L), j (junction), and s (separator). 
For example, you can set the formatters to <code>list(h = "\u2500" , v = "\u2502", l = "\u2514",  j = "\u251C", s = " ")</code>
to get a similar behavior as in <code>fs::dir_tree()</code>.
The defaults are: <code>list(h = "--" , v = "\u00A6", l = "\u00B0", j = "\u00A6", s = " ")</code></p>
</dd>
<dt><code>parent</code></dt>
<dd>
<p>Gets or sets the parent <code>Node</code> of a <code>Node</code>. Only set this if you know what you are doing, as you might mess up the tree structure!</p>
</dd>
<dt><code>children</code></dt>
<dd>
<p>Gets or sets the children <code>list</code> of a <code>Node</code>. Only set this if you know what you are doing, as you might mess up the tree structure!</p>
</dd>
<dt><code>isLeaf</code></dt>
<dd>
<p>Returns <code>TRUE</code> if the <code>Node</code> is a leaf, <code>FALSE</code> otherwise</p>
</dd>
<dt><code>isRoot</code></dt>
<dd>
<p>Returns <code>TRUE</code> if the <code>Node</code> is the root, <code>FALSE</code> otherwise</p>
</dd>
<dt><code>count</code></dt>
<dd>
<p>Returns the number of children of a <code>Node</code></p>
</dd>
<dt><code>totalCount</code></dt>
<dd>
<p>Returns the total number of <code>Node</code>s in the tree</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p>Returns a vector of mode <code>character</code> containing the names of the <code>Node</code>s in the path from the root to this <code>Node</code></p>
</dd>
<dt><code>pathString</code></dt>
<dd>
<p>Returns a string representing the path to this <code>Node</code>, separated by backslash</p>
</dd>
<dt><code>position</code></dt>
<dd>
<p>The position of a <code>Node</code> within its siblings</p>
</dd>
<dt><code>fields</code></dt>
<dd>
<p>Will be deprecated, use <code>attributes</code> instead</p>
</dd>
<dt><code>fieldsAll</code></dt>
<dd>
<p>Will be deprecated, use <code>attributesAll</code> instead</p>
</dd>
<dt><code>attributes</code></dt>
<dd>
<p>The attributes defined on this specific node</p>
</dd>
<dt><code>attributesAll</code></dt>
<dd>
<p>The distinct union of attributes defined on all the nodes in the tree spanned by this <code>Node</code></p>
</dd>
<dt><code>levelName</code></dt>
<dd>
<p>Returns the name of the <code>Node</code>, preceded by level times '*'. Useful for printing and not typically called by package users.</p>
</dd>
<dt><code>leaves</code></dt>
<dd>
<p>Returns a list containing all the leaf <code>Node</code>s</p>
</dd>
<dt><code>leafCount</code></dt>
<dd>
<p>Returns the number of leaves are below a <code>Node</code></p>
</dd>
<dt><code>level</code></dt>
<dd>
<p>Returns an integer representing the level of a <code>Node</code>. For example, the root has level 1.</p>
</dd>
<dt><code>height</code></dt>
<dd>
<p>Returns max(level) of any of the <code>Nodes</code> of the tree</p>
</dd>
<dt><code>isBinary</code></dt>
<dd>
<p>Returns <code>TRUE</code> if all <code>Node</code>s in the tree (except the leaves) have <code>count = 2</code></p>
</dd>
<dt><code>root</code></dt>
<dd>
<p>Returns the root of a <code>Node</code> in a tree.</p>
</dd>
<dt><code>siblings</code></dt>
<dd>
<p>Returns a <code>list</code> containing all the siblings of this <code>Node</code></p>
</dd>
<dt><code>averageBranchingFactor</code></dt>
<dd>
<p>Returns the average number of crotches below this <code>Node</code></p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Node-new"><code>Node$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddChild"><code>Node$AddChild()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddChildNode"><code>Node$AddChildNode()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddSibling"><code>Node$AddSibling()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-AddSiblingNode"><code>Node$AddSiblingNode()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-RemoveChild"><code>Node$RemoveChild()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-RemoveAttribute"><code>Node$RemoveAttribute()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Sort"><code>Node$Sort()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Revert"><code>Node$Revert()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Prune"><code>Node$Prune()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Climb"><code>Node$Climb()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Navigate"><code>Node$Navigate()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Get"><code>Node$Get()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Do"><code>Node$Do()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-Set"><code>Node$Set()</code></a>
</p>
</li>
<li> <p><a href="#method-Node-clone"><code>Node$clone()</code></a>
</p>
</li>
</ul>
<hr>
<a id="method-Node-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Create a new <code>Node</code> object. This is often used to create the root of a tree when creating a tree programmatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$new(name, check = c("check", "no-warn", "no-check"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>the name of the node to be created</p>
</dd>
<dt><code>check</code></dt>
<dd>
<p>Either
</p>

<ul>
<li>
<p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li>
<p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li>
<p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li>
</ul>
</dd>
<dt><code>...</code></dt>
<dd>
<p>A name-value mapping of node attributes</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>A new 'Node' object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>node &lt;- Node$new("mynode", x = 2, y = "value of y")
node$y

</pre>
</div>


<hr>
<a id="method-Node-AddChild"></a>



<h4>Method <code>AddChild()</code>
</h4>

<p>Creates a <code>Node</code> and adds it as the last sibling as a child to the <code>Node</code> on which this is called.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddChild(name, check = c("check", "no-warn", "no-check"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>the name of the node to be created</p>
</dd>
<dt><code>check</code></dt>
<dd>
<p>Either
</p>

<ul>
<li>
<p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li>
<p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li>
<p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li>
</ul>
</dd>
<dt><code>...</code></dt>
<dd>
<p>A name-value mapping of node attributes</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>The new <code>Node</code> (invisibly)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>root &lt;- Node$new("myroot", myname = "I'm the root")
root$AddChild("child1", myname = "I'm the favorite child")
child2 &lt;- root$AddChild("child2", myname = "I'm just another child")
child3 &lt;- child2$AddChild("child3", myname = "Grandson of a root!")
print(root, "myname")

</pre>
</div>


<hr>
<a id="method-Node-AddChildNode"></a>



<h4>Method <code>AddChildNode()</code>
</h4>

<p>Adds a <code>Node</code> as a child to this node.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddChildNode(child)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>child</code></dt>
<dd>
<p>The child <code>"Node"</code> to add.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>the child node added (this lets you chain calls)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
root$AddChildNode(child)

</pre>
</div>


<hr>
<a id="method-Node-AddSibling"></a>



<h4>Method <code>AddSibling()</code>
</h4>

<p>Creates a new <code>Node</code> called <code>name</code> and adds it after this <code>Node</code> as a sibling.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddSibling(name, check = c("check", "no-warn", "no-check"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>the name of the node to be created</p>
</dd>
<dt><code>check</code></dt>
<dd>
<p>Either
</p>

<ul>
<li>
<p><code>"check"</code>: if the name conformance should be checked and warnings should be printed in case of non-conformance (the default)
</p>
</li>
<li>
<p><code>"no-warn"</code>: if the name conformance should be checked, but no warnings should be printed in case of non-conformance (if you expect non-conformance)
</p>
</li>
<li>
<p><code>"no-check" or FALSE</code>: if the name conformance should not be checked; use this if performance is critical. However, in case of non-conformance, expect cryptic follow-up errors
</p>
</li>
</ul>
</dd>
<dt><code>...</code></dt>
<dd>
<p>A name-value mapping of node attributes</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>the sibling node (this lets you chain calls)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>#' root &lt;- Node$new("myroot")
child &lt;- root$AddChild("child1")
sibling &lt;- child$AddSibling("sibling1")

</pre>
</div>


<hr>
<a id="method-Node-AddSiblingNode"></a>



<h4>Method <code>AddSiblingNode()</code>
</h4>

<p>Adds a <code>Node</code> after this <code>Node</code>, as a sibling.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$AddSiblingNode(sibling)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sibling</code></dt>
<dd>
<p>The <code>"Node"</code> to add as a sibling.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>the added sibling node (this lets you chain calls, as in the examples)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
sibling &lt;- Node$new("sibling")
root$AddChildNode(child)$AddSiblingNode(sibling)

</pre>
</div>


<hr>
<a id="method-Node-RemoveChild"></a>



<h4>Method <code>RemoveChild()</code>
</h4>

<p>Remove the child <code>Node</code> called <code>name</code> from a <code>Node</code> and returns it.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$RemoveChild(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>the name of the node to be created</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>the subtree spanned by the removed child.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>node &lt;- Node$new("myroot")$AddChild("mychild")$root
node$RemoveChild("mychild")

</pre>
</div>


<hr>
<a id="method-Node-RemoveAttribute"></a>



<h4>Method <code>RemoveAttribute()</code>
</h4>

<p>Removes attribute called <code>name</code> from this <code>Node</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$RemoveAttribute(name, stopIfNotAvailable = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt>
<dd>
<p>the name of the node to be created</p>
</dd>
<dt><code>stopIfNotAvailable</code></dt>
<dd>
<p>Gives an error if <code>stopIfNotAvailable</code> and the attribute does not exist.</p>
</dd>
</dl>
</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>node &lt;- Node$new("mynode")
node$RemoveAttribute("age", stopIfNotAvailable = FALSE)
node$age &lt;- 27
node$RemoveAttribute("age")
node

</pre>
</div>


<hr>
<a id="method-Node-Sort"></a>



<h4>Method <code>Sort()</code>
</h4>

<p>Sort children of a <code>Node</code> or an entire <code>data.tree</code> structure
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Sort(attribute, ..., decreasing = FALSE, recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attribute</code></dt>
<dd>
<p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li>
<p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li>
<p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li>
<p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li>
</ul>
</dd>
<dt><code>...</code></dt>
<dd>
<p>any parameters to be passed on the the attribute (in case it's a method or a 
function)</p>
</dd>
<dt><code>decreasing</code></dt>
<dd>
<p>sort order</p>
</dd>
<dt><code>recursive</code></dt>
<dd>
<p>if <code>TRUE</code>, the method will be called recursively on the <code>Node</code>'s children. This allows sorting an entire tree.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>You can sort with respect to any argument of the tree. But note that sorting has
side-effects, meaning that you modify the underlying, original data.tree object structure.
</p>
<p>See also <code>Sort</code> for the equivalent function.
</p>



<h5>Returns</h5>

<p>Returns the node on which Sort is called, invisibly. This can be useful to chain Node methods.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Do(function(x) x$totalCost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
Sort(acme, "totalCost", decreasing = FALSE)
print(acme, "totalCost")

</pre>
</div>


<hr>
<a id="method-Node-Revert"></a>



<h4>Method <code>Revert()</code>
</h4>

<p>Reverts the sort order of a <code>Node</code>'s children.
</p>
<p>See also <code>Revert</code> for the equivalent function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Revert(recursive = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recursive</code></dt>
<dd>
<p>if <code>TRUE</code>, the method will be called recursively on the <code>Node</code>'s children. This allows sorting an entire tree.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>returns the Node invisibly (for chaining)
</p>


<hr>
<a id="method-Node-Prune"></a>



<h4>Method <code>Prune()</code>
</h4>

<p>Prunes a tree. 
</p>
<p>Pruning refers to removing entire subtrees. This function has side-effects, it modifies your data.tree structure!
</p>
<p>See also <code>Prune</code> for the equivalent function.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Prune(pruneFun)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pruneFun</code></dt>
<dd>
<p>allows providing a a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>the number of nodes removed
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Do(function(x) x$cost &lt;- Aggregate(x, "cost", sum))
Prune(acme, function(x) x$cost &gt; 700000)
print(acme, "cost")

</pre>
</div>


<hr>
<a id="method-Node-Climb"></a>



<h4>Method <code>Climb()</code>
</h4>

<p>Climb a tree from parent to children, by provided criteria.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Climb(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>an attribute-value pairlist to be searched. For brevity, you can also provide a character vector to search for names.</p>
</dd>
<dt><code>node</code></dt>
<dd>
<p>The root <code>Node</code> of the tree or subtree to climb</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>This method lets you climb the tree, from crutch to crutch. On each <code>Node</code>, the
<code>Climb</code> finds the first child having attribute value equal to the the provided argument.
</p>
<p>See also <code>Climb</code> and <code>Navigate</code>
</p>
<p>Climb(node, ...)
</p>



<h5>Returns</h5>

<p>the <code>Node</code> having path <code>...</code>, or <code>NULL</code> if such a path does not exist
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)

#the following are all equivalent
Climb(acme, 'IT', 'Outsource')
Climb(acme, name = 'IT', name = 'Outsource')
Climb(acme, 'IT')$Climb('Outsource')
Navigate(acme, path = "IT/Outsource")

Climb(acme, name = 'IT')

Climb(acme, position = c(2, 1))
#or, equivalent:
Climb(acme, position = 2, position = 1)
Climb(acme, name = "IT", cost = 250000)

tree &lt;- CreateRegularTree(5, 2)
tree$Climb(c("1", "1"), position = c(2, 2))$path


</pre>
</div>


<hr>
<a id="method-Node-Navigate"></a>



<h4>Method <code>Navigate()</code>
</h4>

<p>Navigate to another node by relative path.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Navigate(path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>path</code></dt>
<dd>
<p>A string or a character vector describing the path to navigate</p>
</dd>
<dt><code>node</code></dt>
<dd>
<p>The starting <code>Node</code> to navigate</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The <code>path</code> is always relative to the <code>Node</code>. Navigation
to the parent is defined by <code>..</code>, whereas navigation to a child
is defined via the child's name.
If path is provided as a string, then the navigation steps are separated
by '/'.
</p>
<p>See also <code>Navigate</code> and <code>Climb</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
Navigate(acme$Research, "../IT/Outsource")
Navigate(acme$Research, c("..", "IT", "Outsource"))

</pre>
</div>


<hr>
<a id="method-Node-Get"></a>



<h4>Method <code>Get()</code>
</h4>

<p>Traverse a Tree and Collect Values
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Get(
  attribute,
  ...,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL,
  format = FALSE,
  inheritFromAncestors = FALSE,
  simplify = c(TRUE, FALSE, "array", "regular")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>attribute</code></dt>
<dd>
<p>determines what is collected. The <code>attribute</code> can be
</p>

<ul>
<li>
<p> a.) the name of a <b>field</b> or a <b>property/active</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("p")</code> or <code>acme$Get("position")</code>
</p>
</li>
<li>
<p> b.) the name of a <b>method</b> of each <code>Node</code> in the tree, e.g. <code>acme$Get("levelZeroBased")</code>, where e.g. <code>acme$levelZeroBased &lt;- function() acme$level - 1</code>
</p>
</li>
<li>
<p> c.) a <b>function</b>, whose first argument must be a <code>Node</code> e.g. <code>acme$Get(function(node) node$cost * node$p)</code>
</p>
</li>
</ul>
</dd>
<dt><code>...</code></dt>
<dd>
<p>in case the <code>attribute</code> is a function or a method, the ellipsis is passed to it as additional arguments.</p>
</dd>
<dt><code>traversal</code></dt>
<dd>
<p>defines the traversal order to be used. This can be
</p>

<dl>
<dt>pre-order</dt>
<dd>
<p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt>
<dd>
<p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt>
<dd>
<p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt>
<dd>
<p>You can also provide a function, whose sole parameter is a <code>Node</code> object. The function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>
<p>Read the data.tree vignette for a detailed explanation of these traversal orders.</p>
</dd>
<dt><code>pruneFun</code></dt>
<dd>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
<dt><code>filterFun</code></dt>
<dd>
<p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</dd>
<dt><code>format</code></dt>
<dd>
<p>if <code>FALSE</code> (the default), no formatting is being used. If <code>TRUE</code>, then the first formatter (if any) found along the ancestor path is being used for formatting 
(see <code>SetFormat</code>). If <code>format</code> is a function, then the collected value is passed to that function, and the result is returned.</p>
</dd>
<dt><code>inheritFromAncestors</code></dt>
<dd>
<p>if <code>TRUE</code>, then the path above a <code>Node</code> is searched to get the <code>attribute</code> in case it is NULL.</p>
</dd>
<dt><code>simplify</code></dt>
<dd>
<p>same as <code>sapply</code>, i.e. TRUE, FALSE or "array". Additionally, you can specify "regular" if
each returned value is of length &gt; 1, and equally named. See below for an example.</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The <code>Get</code> method is one of the most important ones of the <code>data.tree</code> package. It lets you traverse a tree
and collect values along the way. Alternatively, you can call a method or a function on each <code>Node</code>.
</p>
<p>See also <code>Get</code>, <code>Node</code>, <code>Set</code>, <code>Do</code>, <code>Traverse</code>
</p>



<h5>Returns</h5>

<p>a vector containing the <code>atrributes</code> collected during traversal, in traversal order. <code>NULL</code> is converted
to NA, such that <code>length(Node$Get) == Node$totalCount</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Get("level")
acme$Get("totalCount")
 

acme$Get(function(node) node$cost * node$p,
         filterFun = isLeaf)

#This is equivalent:
nodes &lt;- Traverse(acme, filterFun = isLeaf)
Get(nodes, function(node) node$cost * node$p)

   
#simplify = "regular" will preserve names
acme$Get(function(x) c(position = x$position, level = x$level), simplify = "regular")
 
</pre>
</div>


<hr>
<a id="method-Node-Do"></a>



<h4>Method <code>Do()</code>
</h4>

<p>Executes a function on a set of nodes
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Do(
  fun,
  ...,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fun</code></dt>
<dd>
<p>the function to execute. The function is expected to be either a Method, or to take a 
Node as its first argument</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>A name-value mapping of node attributes</p>
</dd>
<dt><code>traversal</code></dt>
<dd>
<p>defines the traversal order to be used. This can be
</p>

<dl>
<dt>pre-order</dt>
<dd>
<p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt>
<dd>
<p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt>
<dd>
<p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt>
<dd>
<p>You can also provide a function, whose sole parameter is a <code>Node</code> object. The function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>
<p>Read the data.tree vignette for a detailed explanation of these traversal orders.</p>
</dd>
<dt><code>pruneFun</code></dt>
<dd>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
<dt><code>filterFun</code></dt>
<dd>
<p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>See also <code>Node</code>, <code>Get</code>, <code>Set</code>, <code>Traverse</code>
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Do(function(node) node$expectedCost &lt;- node$p * node$cost)
print(acme, "expectedCost")

</pre>
</div>


<hr>
<a id="method-Node-Set"></a>



<h4>Method <code>Set()</code>
</h4>

<p>Traverse a Tree and Assign Values
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$Set(
  ...,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt>
<dd>
<p>each argument can be a vector of values to be assigned. Recycled.</p>
</dd>
<dt><code>traversal</code></dt>
<dd>
<p>defines the traversal order to be used. This can be
</p>

<dl>
<dt>pre-order</dt>
<dd>
<p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt>
<dd>
<p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt>
<dd>
<p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt>
<dd>
<p>You can also provide a function, whose sole parameter is a <code>Node</code> object. The function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>
<p>Read the data.tree vignette for a detailed explanation of these traversal orders.</p>
</dd>
<dt><code>pruneFun</code></dt>
<dd>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</dd>
<dt><code>filterFun</code></dt>
<dd>
<p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>The method takes one or more vectors as an argument. It traverses the tree, whereby the values are picked
from the vector. Also available as OO-style method on <code>Node</code>.
</p>
<p>See also <code>Node</code>, <code>Get</code>, <code>Do</code>, <code>Traverse</code>
</p>



<h5>Returns</h5>

<p>invisibly returns the nodes (useful for chaining)
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(acme)
acme$Set(departmentId = 1:acme$totalCount, openingHours = NULL, traversal = "post-order")
acme$Set(head = c("Jack Brown", 
                  "Mona Moneyhead", 
                  "Dr. Frank N. Stein", 
                  "Eric Nerdahl"
                  ),
         filterFun = function(x) !x$isLeaf
        )
print(acme, "departmentId", "head")
 
</pre>
</div>


<hr>
<a id="method-Node-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Node$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>For more details see the <code>data.tree</code> documentations, or the <code>data.tree</code> vignette: <code>vignette("data.tree")</code>
</p>
<p><code>Node</code>
</p>
<p><code>Sort</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(data.tree)
acme &lt;- Node$new("Acme Inc.")
accounting &lt;- acme$AddChild("Accounting")$
              AddSibling("Research")$
              AddChild("New Labs")$
              parent$
              AddSibling("IT")$
              AddChild("Outsource")
print(acme)



## ------------------------------------------------
## Method `Node$new`
## ------------------------------------------------

node &lt;- Node$new("mynode", x = 2, y = "value of y")
node$y


## ------------------------------------------------
## Method `Node$AddChild`
## ------------------------------------------------

root &lt;- Node$new("myroot", myname = "I'm the root")
root$AddChild("child1", myname = "I'm the favorite child")
child2 &lt;- root$AddChild("child2", myname = "I'm just another child")
child3 &lt;- child2$AddChild("child3", myname = "Grandson of a root!")
print(root, "myname")


## ------------------------------------------------
## Method `Node$AddChildNode`
## ------------------------------------------------

root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
root$AddChildNode(child)


## ------------------------------------------------
## Method `Node$AddSibling`
## ------------------------------------------------

#' root &lt;- Node$new("myroot")
child &lt;- root$AddChild("child1")
sibling &lt;- child$AddSibling("sibling1")


## ------------------------------------------------
## Method `Node$AddSiblingNode`
## ------------------------------------------------

root &lt;- Node$new("myroot")
child &lt;- Node$new("mychild")
sibling &lt;- Node$new("sibling")
root$AddChildNode(child)$AddSiblingNode(sibling)


## ------------------------------------------------
## Method `Node$RemoveChild`
## ------------------------------------------------

node &lt;- Node$new("myroot")$AddChild("mychild")$root
node$RemoveChild("mychild")


## ------------------------------------------------
## Method `Node$RemoveAttribute`
## ------------------------------------------------

node &lt;- Node$new("mynode")
node$RemoveAttribute("age", stopIfNotAvailable = FALSE)
node$age &lt;- 27
node$RemoveAttribute("age")
node


## ------------------------------------------------
## Method `Node$Sort`
## ------------------------------------------------

data(acme)
acme$Do(function(x) x$totalCost &lt;- Aggregate(x, "cost", sum), traversal = "post-order")
Sort(acme, "totalCost", decreasing = FALSE)
print(acme, "totalCost")


## ------------------------------------------------
## Method `Node$Prune`
## ------------------------------------------------

data(acme)
acme$Do(function(x) x$cost &lt;- Aggregate(x, "cost", sum))
Prune(acme, function(x) x$cost &gt; 700000)
print(acme, "cost")


## ------------------------------------------------
## Method `Node$Climb`
## ------------------------------------------------

data(acme)

#the following are all equivalent
Climb(acme, 'IT', 'Outsource')
Climb(acme, name = 'IT', name = 'Outsource')
Climb(acme, 'IT')$Climb('Outsource')
Navigate(acme, path = "IT/Outsource")

Climb(acme, name = 'IT')

Climb(acme, position = c(2, 1))
#or, equivalent:
Climb(acme, position = 2, position = 1)
Climb(acme, name = "IT", cost = 250000)

tree &lt;- CreateRegularTree(5, 2)
tree$Climb(c("1", "1"), position = c(2, 2))$path



## ------------------------------------------------
## Method `Node$Navigate`
## ------------------------------------------------

data(acme)
Navigate(acme$Research, "../IT/Outsource")
Navigate(acme$Research, c("..", "IT", "Outsource"))


## ------------------------------------------------
## Method `Node$Get`
## ------------------------------------------------

data(acme)
acme$Get("level")
acme$Get("totalCount")
 

acme$Get(function(node) node$cost * node$p,
         filterFun = isLeaf)

#This is equivalent:
nodes &lt;- Traverse(acme, filterFun = isLeaf)
Get(nodes, function(node) node$cost * node$p)

   
#simplify = "regular" will preserve names
acme$Get(function(x) c(position = x$position, level = x$level), simplify = "regular")
 

## ------------------------------------------------
## Method `Node$Do`
## ------------------------------------------------

data(acme)
acme$Do(function(node) node$expectedCost &lt;- node$p * node$cost)
print(acme, "expectedCost")


## ------------------------------------------------
## Method `Node$Set`
## ------------------------------------------------

data(acme)
acme$Set(departmentId = 1:acme$totalCount, openingHours = NULL, traversal = "post-order")
acme$Set(head = c("Jack Brown", 
                  "Mona Moneyhead", 
                  "Dr. Frank N. Stein", 
                  "Eric Nerdahl"
                  ),
         filterFun = function(x) !x$isLeaf
        )
print(acme, "departmentId", "head")
 
</code></pre>


</div>