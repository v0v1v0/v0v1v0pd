<div class="container">

<table style="width: 100%;"><tr>
<td>Traverse</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Traverse a tree or a sub-tree</h2>

<h3>Description</h3>

<p>Traverse takes the root of a tree or a sub-tree, and "walks" the tree in a specific order. It returns a list of
<code>Node</code> objects, filtered and pruned by <code>filterFun</code> and <code>pruneFun</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">Traverse(
  node,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor"),
  pruneFun = NULL,
  filterFun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>node</code></td>
<td>
<p>the root of a tree or a sub-tree that should be traversed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>traversal</code></td>
<td>
<p>any of 'pre-order' (the default), 'post-order', 'in-order', 'level', 'ancestor', or a custom function (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pruneFun</code></td>
<td>
<p>allows providing a prune criteria, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>. 
If the pruneFun returns FALSE for a Node, then the Node and its entire sub-tree will not be considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filterFun</code></td>
<td>
<p>allows providing a a filter, i.e. a function taking a <code>Node</code> as an input, and returning <code>TRUE</code> or <code>FALSE</code>.
Note that if filter returns <code>FALSE</code>, then the node will be excluded from the result (but not the entire subtree).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The traversal order is as follows. (Note that these descriptions are not precise and complete. They are meant
for quick reference only. See the data.tree vignette for a more detailed description). 
</p>

<dl>
<dt>pre-order</dt>
<dd>
<p>Go to first child, then to its first child, etc.</p>
</dd>
<dt>post-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its siblings, and work your way back to the root</p>
</dd>
<dt>in-order</dt>
<dd>
<p>Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling</p>
</dd>
<dt>level</dt>
<dd>
<p>Collect root, then level 2, then level 3, etc.</p>
</dd>
<dt>ancestor</dt>
<dd>
<p>Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the <code>pruneFun</code> </p>
</dd>
<dt>function</dt>
<dd>
<p>You can also provide a function, whose sole parameter is a <code>Node</code> object. The
function is expected to return the node's next node, a list of the node's next nodes, or NULL.</p>
</dd>
</dl>
<h3>Value</h3>

<p>a list of <code>Node</code>s
</p>


<h3>See Also</h3>

<p><code>Node</code>
</p>
<p><code>Get</code>
</p>
<p><code>Set</code>
</p>
<p><code>Do</code>
</p>


</div>