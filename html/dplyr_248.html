<div class="container">

<table style="width: 100%;"><tr>
<td>scoped</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Operate on a selection of variables</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt="[Superseded]"></a>
</p>
<p>Scoped verbs (<code style="white-space: pre;">⁠_if⁠</code>, <code style="white-space: pre;">⁠_at⁠</code>, <code style="white-space: pre;">⁠_all⁠</code>) have been superseded by the use of
<code>pick()</code> or <code>across()</code> in an existing verb. See <code>vignette("colwise")</code> for
details.
</p>
<p>The variants suffixed with <code style="white-space: pre;">⁠_if⁠</code>, <code style="white-space: pre;">⁠_at⁠</code> or <code style="white-space: pre;">⁠_all⁠</code> apply an
expression (sometimes several) to all variables within a specified
subset. This subset can contain all variables (<code style="white-space: pre;">⁠_all⁠</code> variants), a
<code>vars()</code> selection (<code style="white-space: pre;">⁠_at⁠</code> variants), or variables selected with a
predicate (<code style="white-space: pre;">⁠_if⁠</code> variants).
</p>
<p>The verbs with scoped variants are:
</p>

<ul>
<li> <p><code>mutate()</code>, <code>transmute()</code> and <code>summarise()</code>. See <code>summarise_all()</code>.
</p>
</li>
<li> <p><code>filter()</code>. See <code>filter_all()</code>.
</p>
</li>
<li> <p><code>group_by()</code>. See <code>group_by_all()</code>.
</p>
</li>
<li> <p><code>rename()</code> and <code>select()</code>. See <code>select_all()</code>.
</p>
</li>
<li> <p><code>arrange()</code>. See <code>arrange_all()</code>
</p>
</li>
</ul>
<p>There are three kinds of scoped variants. They differ in the scope
of the variable selection on which operations are applied:
</p>

<ul>
<li>
<p> Verbs suffixed with <code style="white-space: pre;">⁠_all()⁠</code> apply an operation on all variables.
</p>
</li>
<li>
<p> Verbs suffixed with <code style="white-space: pre;">⁠_at()⁠</code> apply an operation on a subset of
variables specified with the quoting function <code>vars()</code>. This
quoting function accepts <code>tidyselect::vars_select()</code> helpers like
<code>starts_with()</code>. Instead of a <code>vars()</code> selection, you can also
supply an integerish vector of column
positions or a character vector of column names.
</p>
</li>
<li>
<p> Verbs suffixed with <code style="white-space: pre;">⁠_if()⁠</code> apply an operation on the subset of
variables for which a predicate function returns <code>TRUE</code>. Instead
of a predicate function, you can also supply a logical vector.
</p>
</li>
</ul>
<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.tbl</code></td>
<td>
<p>A <code>tbl</code> object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.funs</code></td>
<td>
<p>A function <code>fun</code>, a quosure style lambda <code>~ fun(.)</code> or a list of either form.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.vars</code></td>
<td>
<p>A list of columns generated by <code>vars()</code>,
a character vector of column names, a numeric vector of column
positions, or <code>NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.predicate</code></td>
<td>
<p>A predicate function to be applied to the columns
or a logical vector. The variables for which <code>.predicate</code> is or
returns <code>TRUE</code> are selected. This argument is passed to
<code>rlang::as_function()</code> and thus supports quosure-style lambda
functions and strings representing function names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional arguments for the function calls in
<code>.funs</code>. These are evaluated only once, with tidy dots support.</p>
</td>
</tr>
</table>
<h3>Grouping variables</h3>

<p>Most of these operations also apply on the grouping variables when
they are part of the selection. This includes:
</p>

<ul>
<li> <p><code>arrange_all()</code>, <code>arrange_at()</code>, and <code>arrange_if()</code>
</p>
</li>
<li> <p><code>distinct_all()</code>, <code>distinct_at()</code>, and <code>distinct_if()</code>
</p>
</li>
<li> <p><code>filter_all()</code>, <code>filter_at()</code>, and <code>filter_if()</code>
</p>
</li>
<li> <p><code>group_by_all()</code>, <code>group_by_at()</code>, and <code>group_by_if()</code>
</p>
</li>
<li> <p><code>select_all()</code>, <code>select_at()</code>, and <code>select_if()</code>
</p>
</li>
</ul>
<p>This is not the case for summarising and mutating variants where
operations are <em>not</em> applied on grouping variables. The behaviour
depends on whether the selection is <strong>implicit</strong> (<code>all</code> and <code>if</code>
selections) or <strong>explicit</strong> (<code>at</code> selections). Grouping variables
covered by explicit selections (with <code>summarise_at()</code>,
<code>mutate_at()</code>, and <code>transmute_at()</code>) are always an error. For
implicit selections, the grouping variables are always ignored. In
this case, the level of verbosity depends on the kind of operation:
</p>

<ul>
<li>
<p> Summarising operations (<code>summarise_all()</code> and <code>summarise_if()</code>)
ignore grouping variables silently because it is obvious that
operations are not applied on grouping variables.
</p>
</li>
<li>
<p> On the other hand it isn't as obvious in the case of mutating
operations (<code>mutate_all()</code>, <code>mutate_if()</code>, <code>transmute_all()</code>, and
<code>transmute_if()</code>). For this reason, they issue a message
indicating which grouping variables are ignored.
</p>
</li>
</ul>
</div>