<div class="container">

<table style="width: 100%;"><tr>
<td>cross_efficiency</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Cross efficiency analysis</h2>

<h3>Description</h3>

<p>Computes arbitrary, benevolent and aggressive formulations of
cross-efficiency under any returns-to-scale. Doyle and Green (1994) present
three alternatives ways of formulating the secondary goal (wich will minimize
or maximize the other DMUs' cross-efficiencies in some way). Methods II and III
are implemented in deaR with any returns-to-scale. The maverick index is also
calculated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">cross_efficiency(datadea,
                 dmu_eval = NULL,
                 dmu_ref = NULL,
                 epsilon = 0, 
                 orientation = c("io", "oo"),
                 rts = c("crs", "vrs", "nirs", "ndrs", "grs"),
                 L = 1,
                 U = 1,
                 selfapp = TRUE,
                 correction = FALSE,
                 M2 = TRUE,
                 M3 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>datadea</code></td>
<td>
<p>An object of class <code>dea</code> or <code>deadata</code>. If it is of
class <code>dea</code> it must have been obtained with some of the multiplier DEA models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmu_eval</code></td>
<td>
<p>A numeric vector. Only the multipliers of DMUs in <code>dmu_eval</code>
are computed. If <code>NULL</code> (default), all DMUs are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dmu_ref</code></td>
<td>
<p>A numeric vector containing which DMUs are the evaluation reference
set. If <code>NULL</code> (default), all DMUs are considered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epsilon</code></td>
<td>
<p>Numeric, multipliers must be &gt;= <code>epsilon</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orientation</code></td>
<td>
<p>A string, equal to "io" (input-oriented) or "oo" (output-oriented).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rts</code></td>
<td>
<p>A string, determining the type of returns to scale, equal to "crs" (constant),
"vrs" (variable), "nirs" (non-increasing), "ndrs" (non-decreasing) or "grs" (generalized).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>L</code></td>
<td>
<p>Lower bound for the generalized returns to scale (grs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>U</code></td>
<td>
<p>Upper bound for the generalized returns to scale (grs).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selfapp</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, self-appraisal is included in the
average scores of <code>A</code> and <code>e</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correction</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, a correction is applied in the
"vrs" input-oriented model in order to avoid negative cross-efficiencies,
according to Lim &amp; Zhu (2015).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M2</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, it computes Method II for aggresive/benevolent
estimations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>M3</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, it computes Method III for aggresive/benevolent
estimations.</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>(1) We can obtain negative cross-efficiency in the input-oriented DEA model
under no constant returns-to-scale. However, the same does not happen in the case
of the output-oriented VRS DEA model. For this reason, the proposal of
Lim and Zhu (2015) is implemented in deaR to calculate the input-oriented
cross-efficiency model under no constant returns-to-scale.
</p>
<p>(2) The multiplier model can have alternate optimal solutions (see note 1 in
model_multiplier). So, depending on the optimal weights selected we can obtain
different cross-efficiency scores.
</p>


<h3>Author(s)</h3>

<p><strong>Vicente Coll-Serrano</strong> (<a href="mailto:vicente.coll@uv.es">vicente.coll@uv.es</a>).
<em>Quantitative Methods for Measuring Culture (MC2). Applied Economics.</em>
</p>
<p><strong>Vicente Bolós</strong> (<a href="mailto:vicente.bolos@uv.es">vicente.bolos@uv.es</a>).
<em>Department of Business Mathematics</em>
</p>
<p><strong>Rafael Benítez</strong> (<a href="mailto:rafael.suarez@uv.es">rafael.suarez@uv.es</a>).
<em>Department of Business Mathematics</em>
</p>
<p>University of Valencia (Spain)
</p>


<h3>References</h3>

<p>Sexton, T.R., Silkman, R.H.; Hogan, A.J. (1986). Data envelopment analysis: critique
and extensions. In: Silkman RH (ed) Measuring efficiency: an assessment of data
envelopment analysis, vol 32. Jossey-Bass, San Francisco, pp 73–104. <a href="https://doi.org/10.1002/ev.1441">doi:10.1002/ev.1441</a>  
</p>
<p>Doyle, J.; Green, R. (1994). “Efficiency and cross efficiency in DEA: derivations,
meanings and the uses”,  Journal of Operational Research Society, 45(5), 567–578.
<a href="https://doi.org/10.2307/2584392">doi:10.2307/2584392</a> 
</p>
<p>Cook, W.D.; Zhu, J. (2015). DEA Cross Efficiency. In: Zhu, J. (ed) Data Envelopment
Analysis. A Handbook of Models and Methods. International Series in Operations
Research &amp; Management Science, vol 221. Springer, Boston, MA, 23-43.
<a href="https://doi.org/10.1007/978-1-4899-7553-9_2">doi:10.1007/978-1-4899-7553-9_2</a> 
</p>
<p>Lim, S.; Zhu, J. (2015). "DEA Cross-Efficiency Under Variable Returns to Scale".
Journal of Operational Research Society, 66(3), p. 476-487.
<a href="https://doi.org/10.1057/jors.2014.13">doi:10.1057/jors.2014.13</a>
</p>


<h3>See Also</h3>

<p><code>model_multiplier</code>, <code>cross_efficiency_fuzzy</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Example 1.
# Arbitrary formulation. Input-oriented model under constant returns-to-scale.
data("Golany_Roll_1989")
data_example &lt;- make_deadata(datadea = Golany_Roll_1989, 
                             inputs = 2:4, 
                             outputs = 5:6)
result &lt;- cross_efficiency(data_example, 
                           orientation = "io", 
                           rts = "crs", 
                           selfapp = TRUE)
result$Arbitrary$cross_eff
result$Arbitrary$e

# Example 2.
# Benevolent formulation (method II). Input-oriented.
data("Golany_Roll_1989")
data_example &lt;- make_deadata(datadea = Golany_Roll_1989, 
                             inputs = 2:4, 
                             outputs = 5:6)
result &lt;- cross_efficiency(data_example, 
                           orientation = "io", 
                           selfapp = TRUE)
result$M2_ben$cross_eff
result$M2_ben$e

# Example 3.
# Benevolent formulation (method III). Input-oriented.
data("Golany_Roll_1989")
data_example &lt;- make_deadata(datadea = Golany_Roll_1989, 
                             inputs = 2:4, 
                             outputs = 5:6)
result &lt;- cross_efficiency(data_example, 
                           orientation = "io", 
                           selfapp = TRUE)
result$M3_ben$cross_eff
result$M3_ben$e
  
# Example 4.
# Arbitrary formulation. Output-oriented.
data("Golany_Roll_1989")
data_example &lt;- make_deadata(datadea = Golany_Roll_1989,
                             inputs = 2:4, 
                             outputs = 5:6)
result &lt;- cross_efficiency(data_example, 
                           orientation = "oo", 
                           selfapp = TRUE)
result$Arbitrary$cross_eff
result$Arbitrary$e

# Example 5.
# Arbitrary formulation. Input-oriented model under vrs returns-to-scale.
data("Lim_Zhu_2015")
data_example &lt;- make_deadata(Lim_Zhu_2015,
                             ni = 1, 
                             no = 5)
cross &lt;- cross_efficiency(data_example,
                          epsilon = 0,
                          orientation = "io",
                          rts = "vrs",
                          selfapp = TRUE,
                          M2 = FALSE,
                          M3 = FALSE)
cross$Arbitrary$e

</code></pre>


</div>