<div class="container">

<table style="width: 100%;"><tr>
<td>solve-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Methods for Function solve in Package ‘distr’ </h2>

<h3>Description</h3>

<p>solve-methods using generalized inverses for various types of matrices</p>


<h3>Usage</h3>

<pre><code class="language-R">solve(a,b, ...)
## S4 method for signature 'ANY,ANY'
solve(a, b, generalized = 
getdistrOption("use.generalized.inverse.by.default"), tol = 1e-10)
## S4 method for signature 'PosSemDefSymmMatrix,ANY'
solve(a, b, generalized =
getdistrOption("use.generalized.inverse.by.default"), tol = 1e-10)
## S4 method for signature 'PosDefSymmMatrix,ANY'
solve(a, b, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>a</code></td>
<td>
<p>matrix to be inverted / to be solved for RHS.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>b</code></td>
<td>
<p>a numeric or complex vector or matrix giving the right-hand
side(s) of the linear system.  If missing, <code>b</code> is taken to be
an identity matrix and <code>solve</code> will return the inverse of
<code>a</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments to be passed to specific methods (see <code>solve</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>generalized</code></td>
<td>
<p> logical: should generalized / Moore-Penrose inverses be used? By default uses
the corresponding global option to be set by <code>distroptions</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p> the tolerance for detecting linear dependencies in the
columns of <code>a</code>.  Default is <code>.Machine$double.eps</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The method for the Moore-Penrose inverse for 
<code>signature(a = "PosSemDefSymmMatrix", b = "ANY")</code> uses <code>eigen</code> to find the eigenvalue 
decomposition of <code>a</code> and then simply "pseudo-inverts" the corresponding diagonal matrix built from
<code>eigen(a)$values</code>, while for <code>signature(a = "ANY", b = "ANY")</code>  it uses the svd 
decomposition of <code>a</code> and then simply "pseudo-inverts" the corresponding diagonal matrix built from
<code>svd(a)$d</code>.</p>


<h3>Methods</h3>


<dl>
<dt>solve</dt>
<dd>
<p><code>signature(a = "ANY", b = "ANY")</code>: tries to evaluate <code>solve.default</code> method from <span class="pkg">base</span> in classical way;
if this gives an error, this one is returned if <code>generalized</code> is <code>TRUE</code>, else it will then
return <code class="reqn">a^-b</code> where <code class="reqn">a^-</code> is the pseudo or Moore-Penrose inverse of <code class="reqn">a</code>.</p>
</dd>
<dt>solve</dt>
<dd>
<p><code>signature(a = "PosSemDefSymmMatrix", b = "ANY")</code>: evaluates <code class="reqn">a^-b</code> where <code class="reqn">a^-</code> is the pseudo or Moore-Penrose
inverse of <code class="reqn">a</code>.</p>
</dd>
<dt>solve</dt>
<dd>
<p><code>signature(a = "PosDefSymmMatrix", b = "ANY")</code>: evaluates solve method from <span class="pkg">base</span> in classical way.</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>See Also</h3>

<p><code>solve</code> for the default method, <code>eigen</code> and <code>svd</code> 
for the pseudo inversion</p>


</div>