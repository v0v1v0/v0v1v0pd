<div class="container">

<table style="width: 100%;"><tr>
<td>DoubleMLIIVM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Double machine learning for interactive IV regression models</h2>

<h3>Description</h3>

<p>Double machine learning for interactive IV regression models.
</p>


<h3>Format</h3>

<p>R6::R6Class object inheriting from DoubleML.
</p>


<h3>Details</h3>

<p>Interactive IV regression (IIVM) models take the form
</p>
<p><code class="reqn">Y = \ell_0(D,X) + \zeta</code>,
</p>
<p><code class="reqn">Z = m_0(X) + V</code>,
</p>
<p>with <code class="reqn">E[\zeta|X,Z]=0</code> and <code class="reqn">E[V|X] = 0</code>. <code class="reqn">Y</code> is the outcome
variable, <code class="reqn">D \in \{0,1\}</code> is the binary treatment variable and
<code class="reqn">Z \in \{0,1\}</code> is a binary instrumental variable. Consider the functions
<code class="reqn">g_0</code>, <code class="reqn">r_0</code> and <code class="reqn">m_0</code>, where <code class="reqn">g_0</code> maps the support of
<code class="reqn">(Z,X)</code> to <code class="reqn">R</code> and <code class="reqn">r_0</code> and <code class="reqn">m_0</code>, respectively, map the
support of <code class="reqn">(Z,X)</code> and <code class="reqn">X</code> to <code class="reqn">(\epsilon, 1-\epsilon)</code> for some
<code class="reqn">\epsilon \in (1, 1/2)</code>, such that
</p>
<p><code class="reqn">Y = g_0(Z,X) + \nu,</code>
</p>
<p><code class="reqn">D = r_0(Z,X) + U,</code>
</p>
<p><code class="reqn">Z = m_0(X) + V,</code>
</p>
<p>with <code class="reqn">E[\nu|Z,X]=0</code>, <code class="reqn">E[U|Z,X]=0</code> and <code class="reqn">E[V|X]=0</code>. The target
parameter of interest in this model is the local average treatment effect
(LATE),
</p>
<p><code class="reqn">\theta_0 = \frac{E[g_0(1,X)] - E[g_0(0,X)]}{E[r_0(1,X)] - E[r_0(0,X)]}.</code>
</p>


<h3>Super class</h3>

<p><code>DoubleML::DoubleML</code> -&gt; <code>DoubleMLIIVM</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>subgroups</code></dt>
<dd>
<p>(named <code>list(2)</code>) <br>
Named <code>list(2)</code> with options to adapt to cases with and without the
subgroups of always-takers and never-takes.
The entry <code>always_takers</code>(<code>logical(1)</code>) speficies whether there are
always takers in the sample. The entry <code>never_takers</code> (<code>logical(1)</code>)
speficies whether there are never takers in the sample.</p>
</dd>
<dt><code>trimming_rule</code></dt>
<dd>
<p>(<code>character(1)</code>) <br>
A <code>character(1)</code> specifying the trimming approach.</p>
</dd>
<dt><code>trimming_threshold</code></dt>
<dd>
<p>(<code>numeric(1)</code>) <br>
The threshold used for timming.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DoubleMLIIVM-new"><code>DoubleMLIIVM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DoubleMLIIVM-clone"><code>DoubleMLIIVM$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="bootstrap"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-bootstrap"><code>DoubleML::DoubleML$bootstrap()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="confint"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-confint"><code>DoubleML::DoubleML$confint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="fit"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-fit"><code>DoubleML::DoubleML$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="get_params"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-get_params"><code>DoubleML::DoubleML$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="learner_names"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-learner_names"><code>DoubleML::DoubleML$learner_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="p_adjust"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-p_adjust"><code>DoubleML::DoubleML$p_adjust()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="params_names"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-params_names"><code>DoubleML::DoubleML$params_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="print"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-print"><code>DoubleML::DoubleML$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="set_ml_nuisance_params"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-set_ml_nuisance_params"><code>DoubleML::DoubleML$set_ml_nuisance_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="set_sample_splitting"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-set_sample_splitting"><code>DoubleML::DoubleML$set_sample_splitting()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="split_samples"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-split_samples"><code>DoubleML::DoubleML$split_samples()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="summary"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-summary"><code>DoubleML::DoubleML$summary()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="tune"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-tune"><code>DoubleML::DoubleML$tune()</code></a></span></li>
</ul></details><hr>
<a id="method-DoubleMLIIVM-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>DoubleMLIIVM$new(
  data,
  ml_g,
  ml_m,
  ml_r,
  n_folds = 5,
  n_rep = 1,
  score = "LATE",
  subgroups = list(always_takers = TRUE, never_takers = TRUE),
  dml_procedure = "dml2",
  trimming_rule = "truncate",
  trimming_threshold = 1e-12,
  draw_sample_splitting = TRUE,
  apply_cross_fitting = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>(<code>DoubleMLData</code>) <br>
The <code>DoubleMLData</code> object providing the data and specifying the variables
of the causal model.</p>
</dd>
<dt><code>ml_g</code></dt>
<dd>
<p>(<code>LearnerRegr</code>,
<code>LearnerClassif</code>, <code>Learner</code>,
<code>character(1)</code>) <br>
A learner of the class <code>LearnerRegr</code>, which is
available from <a href="https://mlr3.mlr-org.com/index.html">mlr3</a> or its
extension packages <a href="https://mlr3learners.mlr-org.com/">mlr3learners</a> or
<a href="https://mlr3extralearners.mlr-org.com/">mlr3extralearners</a>.
For binary treatment outcomes, an object of the class
<code>LearnerClassif</code> can be passed, for example
<code>lrn("classif.cv_glmnet", s = "lambda.min")</code>.
Alternatively, a <code>Learner</code> object with public field
<code>task_type = "regr"</code> or <code>task_type = "classif"</code> can be passed,
respectively, for example of class
<code>GraphLearner</code>. <br><code>ml_g</code> refers to the nuisance function <code class="reqn">g_0(Z,X) = E[Y|X,Z]</code>.</p>
</dd>
<dt><code>ml_m</code></dt>
<dd>
<p>(<code>LearnerClassif</code>,
<code>Learner</code>, <code>character(1)</code>) <br>
A learner of the class <code>LearnerClassif</code>, which is
available from <a href="https://mlr3.mlr-org.com/index.html">mlr3</a> or its
extension packages <a href="https://mlr3learners.mlr-org.com/">mlr3learners</a> or
<a href="https://mlr3extralearners.mlr-org.com/">mlr3extralearners</a>.
Alternatively, a <code>Learner</code> object with public field
<code>task_type = "classif"</code> can be passed, for example of class
<code>GraphLearner</code>. The learner can possibly
be passed with specified parameters, for example
<code>lrn("classif.cv_glmnet", s = "lambda.min")</code>. <br><code>ml_m</code> refers to the nuisance function <code class="reqn">m_0(X) = E[Z|X]</code>.</p>
</dd>
<dt><code>ml_r</code></dt>
<dd>
<p>(<code>LearnerClassif</code>,
<code>Learner</code>, <code>character(1)</code>) <br>
A learner of the class <code>LearnerClassif</code>, which is
available from <a href="https://mlr3.mlr-org.com/index.html">mlr3</a> or its
extension packages <a href="https://mlr3learners.mlr-org.com/">mlr3learners</a> or
<a href="https://mlr3extralearners.mlr-org.com/">mlr3extralearners</a>.
Alternatively, a <code>Learner</code> object with public field
<code>task_type = "classif"</code> can be passed, for example of class
<code>GraphLearner</code>. The learner can possibly
be passed with specified parameters, for example
<code>lrn("classif.cv_glmnet", s = "lambda.min")</code>. <br><code>ml_r</code> refers to the nuisance function <code class="reqn">r_0(Z,X) = E[D|X,Z]</code>.</p>
</dd>
<dt><code>n_folds</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of folds. Default is <code>5</code>.</p>
</dd>
<dt><code>n_rep</code></dt>
<dd>
<p>(<code>integer(1)</code>) <br>
Number of repetitions for the sample splitting. Default is <code>1</code>.</p>
</dd>
<dt><code>score</code></dt>
<dd>
<p>(<code>character(1)</code>, <code style="white-space: pre;">⁠function()⁠</code>) <br>
A <code>character(1)</code> (<code>"LATE"</code> is the only choice) specifying the score
function.
If a <code style="white-space: pre;">⁠function()⁠</code> is provided, it must be of the form
<code style="white-space: pre;">⁠function(y, z, d, g0_hat, g1_hat, m_hat, r0_hat, r1_hat, smpls)⁠</code> and
the returned output must be a named <code>list()</code> with elements <code>psi_a</code> and
<code>psi_b</code>. Default is <code>"LATE"</code>.</p>
</dd>
<dt><code>subgroups</code></dt>
<dd>
<p>(named <code>list(2)</code>) <br>
Named <code>list(2)</code> with options to adapt to cases with and without the
subgroups of always-takers and never-takes. The entry
<code>always_takers</code>(<code>logical(1)</code>) speficies whether there are always takers
in the sample. The entry <code>never_takers</code> (<code>logical(1)</code>) speficies whether
there are never takers in the sample. Default is
<code>list(always_takers = TRUE, never_takers = TRUE)</code>.</p>
</dd>
<dt><code>dml_procedure</code></dt>
<dd>
<p>(<code>character(1)</code>) <br>
A <code>character(1)</code> (<code>"dml1"</code> or <code>"dml2"</code>) specifying the double machine
learning algorithm. Default is <code>"dml2"</code>.</p>
</dd>
<dt><code>trimming_rule</code></dt>
<dd>
<p>(<code>character(1)</code>) <br>
A <code>character(1)</code> (<code>"truncate"</code> is the only choice) specifying the
trimming approach. Default is <code>"truncate"</code>.</p>
</dd>
<dt><code>trimming_threshold</code></dt>
<dd>
<p>(<code>numeric(1)</code>) <br>
The threshold used for timming. Default is <code>1e-12</code>.</p>
</dd>
<dt><code>draw_sample_splitting</code></dt>
<dd>
<p>(<code>logical(1)</code>) <br>
Indicates whether the sample splitting should be drawn during
initialization of the object. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>apply_cross_fitting</code></dt>
<dd>
<p>(<code>logical(1)</code>) <br>
Indicates whether cross-fitting should be applied. Default is <code>TRUE</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DoubleMLIIVM-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DoubleMLIIVM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>Other DoubleML: 
<code>DoubleML</code>,
<code>DoubleMLIRM</code>,
<code>DoubleMLPLIV</code>,
<code>DoubleMLPLR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(DoubleML)
library(mlr3)
library(mlr3learners)
library(data.table)
set.seed(2)
ml_g = lrn("regr.ranger",
  num.trees = 100, mtry = 20,
  min.node.size = 2, max.depth = 5)
ml_m = lrn("classif.ranger",
  num.trees = 100, mtry = 20,
  min.node.size = 2, max.depth = 5)
ml_r = ml_m$clone()
obj_dml_data = make_iivm_data(
  theta = 0.5, n_obs = 1000,
  alpha_x = 1, dim_x = 20)
dml_iivm_obj = DoubleMLIIVM$new(obj_dml_data, ml_g, ml_m, ml_r)
dml_iivm_obj$fit()
dml_iivm_obj$summary()


## Not run: 
library(DoubleML)
library(mlr3)
library(mlr3learners)
library(mlr3tuning)
library(data.table)
set.seed(2)
ml_g = lrn("regr.rpart")
ml_m = lrn("classif.rpart")
ml_r = ml_m$clone()
obj_dml_data = make_iivm_data(
  theta = 0.5, n_obs = 1000,
  alpha_x = 1, dim_x = 20)
dml_iivm_obj = DoubleMLIIVM$new(obj_dml_data, ml_g, ml_m, ml_r)
param_grid = list(
  "ml_g" = paradox::ps(
    cp = paradox::p_dbl(lower = 0.01, upper = 0.02),
    minsplit = paradox::p_int(lower = 1, upper = 2)),
  "ml_m" = paradox::ps(
    cp = paradox::p_dbl(lower = 0.01, upper = 0.02),
    minsplit = paradox::p_int(lower = 1, upper = 2)),
  "ml_r" = paradox::ps(
    cp = paradox::p_dbl(lower = 0.01, upper = 0.02),
    minsplit = paradox::p_int(lower = 1, upper = 2)))
# minimum requirements for tune_settings
tune_settings = list(
  terminator = mlr3tuning::trm("evals", n_evals = 5),
  algorithm = mlr3tuning::tnr("grid_search", resolution = 5))
dml_iivm_obj$tune(param_set = param_grid, tune_settings = tune_settings)
dml_iivm_obj$fit()
dml_iivm_obj$summary()

## End(Not run)

</code></pre>


</div>