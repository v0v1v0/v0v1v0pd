<div class="container">

<table style="width: 100%;"><tr>
<td>Kkronm</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>The product of Kronecker Product of some Arrays</h2>

<h3>Description</h3>

<p>This is an auxiliary function and requires some context to be used adequadely. It computes equation (19) in Prass and Pumi (2019), returning a square matrix defined by </p>
<p style="text-align: center;"><code class="reqn">K* = (Jm \%x\%  J*)'(Q \%x\%  Q)(Jm \%x\%  J*)</code>
</p>
<p> where:
</p>

<ul>
<li> <p><code class="reqn">J</code> is an <code class="reqn">(m+1)*(h+1) - m*h*s</code> by <code class="reqn">(m+1)*(h+1) - m*h*s</code> lower triangular matrix with all non-zero entries equal to one,  with <code class="reqn">s = 1</code> if overlap = TRUE and <code class="reqn">s = 0</code>, otherwise;
</p>
</li>
<li> <p><code class="reqn">Jm</code> corresponds to the first <code class="reqn">m+1</code> rows and columns of <code class="reqn">J</code>;
</p>
</li>
<li> <p><code class="reqn">J*</code> corresponds to the last <code class="reqn">m+1</code> rows of <code class="reqn">J</code>;
</p>
</li>
<li> <p><code class="reqn">Q = I-P</code>, where <code class="reqn">P</code> is the <code class="reqn">m+1</code> by <code class="reqn">m+1</code> projection matrix into the subspace generated by degree <code class="reqn">nu+1</code> polynomials.
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R">Kkronm(m = 3, nu = 0, h = 0, overlap = TRUE, K = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>a positive integer indicating the size of the window for the polinomial fit.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nu</code></td>
<td>
<p>a non-negative integer denoting the degree of the polinomial fit applied on the integrated series.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>an integer indicating the lag.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>overlap</code></td>
<td>
<p>logical: if true (the default), overlapping boxes are used for calculations. Otherwise, non-overlapping boxes are applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>K</code></td>
<td>
<p>optional: the matrix defined by <code class="reqn">K = J'QJ</code>. This is used to  calculate <code class="reqn">K* = (Jm \%x\%  J*)'(Q \%x\%  Q)(Jm \%x\%  J*)</code>. For details see (19) in Prass and Pumi (2019). If this matrix is provided <code class="reqn">mu</code> is ignored.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>an <code class="reqn">(m+1)[(m+1)*(h+1) - m*h*s]</code> by <code class="reqn">(m+1)[(m+1)*(h+1) - m*h*s]</code> matrix, where <code class="reqn">s = 1</code> if overlap = TRUE and <code class="reqn">s = 0</code>, otherwise. This matrix corresponds to equation (19) in Prass and Pumi (2019).
</p>


<h3>Author(s)</h3>

<p>Taiane Schaedler Prass</p>


<h3>References</h3>

<p>Prass, T.S. and Pumi, G. (2019). On the behavior of the DFA and DCCA in trend-stationary
processes &lt;arXiv:1910.10589&gt;.</p>


<h3>See Also</h3>

<p><code>Jn</code> which creates the matrix <code class="reqn">J</code>, <code>Qm</code> which creates <code class="reqn">Q</code> and <code>Km</code> which creates <code class="reqn">K</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">m = 3
h = 1
J = Jn(n = m+1+h)
Q = Qm(m = m, nu = 0)

# using K
K = Km(J = J[1:(m+1),1:(m+1)], Q = Q)
Kkron0 = Kkronm(K = K, h = h)

# using m and nu
Kkron = Kkronm(m = m, nu = 0, h = h)

# using  kronecker product from R
K = Km(J = J[1:(m+1),1:(m+1)], Q = Q)
Kh = rbind(matrix(0, nrow = h, ncol = m+1+h),
           cbind(matrix(0, nrow = m+1, ncol = h), K))
KkronR = K %x% Kh

# using  the definition K* = (Jm %x%  J)'(Q %x%  Q)(Jm %x%  J)
J_m = J[1:(m+1),1:(m+1)]
J_h = J[(h+1):(m+1+h),1:(m+1+h)]
KkronD = t(J_m %x%  J_h)%*%(Q %x%  Q)%*%(J_m %x%  J_h)


# comparing the results
sum(abs(Kkron0 - Kkron))
sum(abs(Kkron0 - KkronR))
sum(abs(Kkron0 - KkronD))  # difference due to rounding error

## Not run: 
# Function Kkronm is computationaly faster than a pure implementation in R:

m = 100
h = 1
J = Jn(n = m+1)
Q = Qm(m = m, nu = 0)

# using Kkronm
t1 = proc.time()
Kkron = Kkronm(m = m, nu = 0, h = 1)
t2 = proc.time()
# elapsed time:
t2-t1

# Pure R implementation:
K = Km(J = J, Q = Q)
Kh = rbind(matrix(0, nrow = h, ncol = m+1+h),
           cbind(matrix(0, nrow = m+1, ncol = h), K))
t3 = proc.time()
KkronR = K %x% Kh
t4 = proc.time()
# elapsed time
t4-t3


## End(Not run)
</code></pre>


</div>