<div class="container">

<table style="width: 100%;"><tr>
<td>kde</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Univariate kernel density estimation directly in R code.
</h2>

<h3>Description</h3>

<p>This function behaves similarly to the <code>density</code> function of the
<span class="pkg">stats</span> package, but uses only R code.  It is a demonstration
function intended to show how kernel density estimates are
computed, at least conceptually.  Unlike <code>density</code>, the kernel
may be supplied as an R function in a standard form.  Example kernel
functions are provided.  For computational efficiency, the
<code>density</code> function of the <span class="pkg">stats</span> package is far superior.
</p>


<h3>Usage</h3>

<pre><code class="language-R">kde(x, bw = bw.nrd0, kernel = kernelGaussian, n = 512,
    from = min(x) - cut * sd, to = max(x) + cut * sd,
    adjust = 1, cut = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>Univeriate sample.  Must be numeric.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bw</code></td>
<td>

<p>Either an explicit numeric bandwidth to be used for the kernel, or a
function used to calculate it.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>kernel</code></td>
<td>

<p>The kernel function to be used.  Must have the same argument
sequence as <code>kernelGaussian</code>, with the same meanings.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>

<p>Then number of points covering the range at which to evaluate the
KDE.  More gives a smoother display of the result; fewer gives a
quicker and more memory efficient computation.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>

<p>Lower boundary for the computed KDE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>

<p>Upper boundary for the computed KDE.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adjust</code></td>
<td>

<p>Adjustment factor to be used for the bandwidth.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cut</code></td>
<td>

<p>Number of bandwidths by which to extend the range of
the data for the range of the KDE
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>

<p>Additional arguments, if needed, to be supplied to the kernel
function.
</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This is a demonstration function intended to show, via R code, the way
in which a kernel density estimate is computed.
</p>
<p>For samples which are not too large the computation is reasonably
efficient, but for serious computations the standard function
<code>density</code>, or some alternative, should be
used.
</p>


<h3>Value</h3>

<p>An object of class “density”, with essentially the same
structure as objects generated by the <code>density</code>
of the <span class="pkg">stats</span> package.  <code>plot</code> and allied methods should apply.
</p>


<h3>Note</h3>

<p>Demonstration code only!
</p>


<h3>Author(s)</h3>

<p>Bill Venables
</p>


<h3>See Also</h3>

<p><code>kernelBiweight</code> and aliases; <code>density</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">if(require("graphics")) {
  with(MASS::geyser, {
      hist(waiting, freq=FALSE, main="", border="grey", las=1)
      lines(stats::density(waiting), col="skyblue", lwd=8)
      lines(kde(waiting))
      lines(kde(waiting, kernel = kernelUniform), col="red")
      rug(jitter(waiting), col="blue")
      legend("topleft", c("density histogram",
        "KDE gaussian (denstiy)", "KDE gaussian (kde)",
        "KDE rectangular (kde)"), lty = "solid", lwd=c(1,8,1,1),
        col=c("grey", "skyblue", "black", "red"), bty="n")
  })
}
</code></pre>


</div>