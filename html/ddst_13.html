<div class="container">

<table style="width: 100%;"><tr>
<td>ddst.uniform.test</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2> Data Driven Smooth Test for Uniformity </h2>

<h3>Description</h3>

<p>Performs data driven smooth tests for simple hypothesis of uniformity on [0,1].
</p>


<h3>Usage</h3>

<pre><code class="language-R">ddst.uniform.test(x, base = ddst.base.legendre, c = 2.4, B = 1000, compute.p = F,
    Dmax = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>  a (non-empty) numeric vector of data values. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>base</code></td>
<td>
<p> a function which returns orthogonal system, might be <code>ddst.base.legendre</code> for Legendre polynomials or <code>ddst.base.cos</code> for cosine system, see package description. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>c</code></td>
<td>
<p> a parameter for model selection rule, see package description. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>B</code></td>
<td>
<p> an integer specifying the number of replicates used in p-value computation. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compute.p</code></td>
<td>
<p>  a logical value indicating whether to compute a p-value. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dmax</code></td>
<td>
<p> an integer specifying the maximum number of coordinates, only for advanced users. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments. </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Embeding null model into the original exponential family introduced by Neyman (1937) leads to the information matrix <em> I</em> being identity and smooth test statistic with <em>k</em> components
<em>
$W_k=[1/sqrt(n) sum_j=1^k sum_i=1^n phi_j(Z_i)]^2$</em>,
where <em>$phi_j$</em> is <em>j</em>th degree normalized Legendre polynomial on [0,1] (default value of parameter base = ‘ddst.base.legendre’). Alternatively, in our implementation, cosine system can be selected (base = ‘ddst.base.cos’). For details see Ledwina (1994) and Inglot and Ledwina (2006).
</p>
<p>An application of the pertaining selection rule <em>T</em> for choosing <em>k</em> gives related ‘ddst.uniform.test()’ based on statistic <em>$W_T$</em>.
</p>
<p>Similar approach applies to testing goodness-of-fit to any fully specified continuous distribution function <em>F</em>. For this purpose it is enough to apply the above solution to transformed observations <em>$F(z_1),...,F(z_n)$</em>.
</p>
<p>For more details see: <a href="http://www.biecek.pl/R/ddst/description.pdf">http://www.biecek.pl/R/ddst/description.pdf</a>.
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code>
</p>
<table>
<tr style="vertical-align: top;">
<td><code>statistic </code></td>
<td>
<p>the value of the test statistic.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameter </code></td>
<td>
<p>the number of choosen coordinates (k).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method </code></td>
<td>
<p>a character string indicating the parameters of performed test. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.name </code></td>
<td>
<p>a character string giving the name(s) of the data. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p.value </code></td>
<td>
<p>the p-value for the test, computed only if <code>compute.p=T</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p> Przemyslaw Biecek and Teresa Ledwina </p>


<h3>References</h3>

<p>Inglot, T., Ledwina, T. (2006). Towards data driven selection of a penalty function for data driven Neyman tests. <em> Linear Algebra and its Appl.</em> <b> 417</b>, 579–590.
</p>
<p>Ledwina, T. (1994). Data driven version of Neyman's smooth test of fit. <em> J. Amer. Statist. Assoc.</em> <b> 89</b> 1000-1005.
</p>
<p>Neyman, J. (1937). ‘Smooth test’ for goodness of fit. <em>Skand. Aktuarietidskr.</em> <b> 20</b>, 149-199.
</p>


<h3>Examples</h3>

<pre><code class="language-R">
# H0 is true
z = runif(80)
ddst.uniform.test(z, compute.p=TRUE)

# known fixed alternative
z = rnorm(80,10,16)
ddst.uniform.test(pnorm(z, 10, 16), compute.p=TRUE)


# H0 is false
z = rbeta(80,4,2)
(t = ddst.uniform.test(z, compute.p=TRUE))
t$p.value

</code></pre>


</div>