<div class="container">

<table style="width: 100%;"><tr>
<td>workflowNullPsi</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Computes the dissimilarity measure <em>psi</em> on restricted permutations of two or more sequences.</h2>

<h3>Description</h3>

<p>The function first computes psi on the observed sequences, and then computes it on permutations of the input sequences by the <code>repetitions</code> argument. The data is randomized as follows: within each column, each data-point can be: 1) left as is; 2) replaced by the previous case; 3) replaced by the next case. The action applied to each data-point is selected randomly, and independently from the actions applied to other data-points. This type of randomization generates versions of the dataset that have the same general structure as the original one, but small local and independent changes only ocurring within the immediate neighborhood (one row up or down) of each case in the table. The method should generate very conservative random values of <code>psi</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">workflowNullPsi(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  diagonal = FALSE,
  paired.samples = FALSE,
  same.time = FALSE,
  ignore.blocks = FALSE,
  parallel.execution = TRUE,
  repetitions = 9
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sequences</code></td>
<td>
<p>dataframe with multiple sequences identified by a grouping column generated by <code>prepareSequences</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grouping.column</code></td>
<td>
<p>character string, name of the column in <code>sequences</code> to be used to identify separates sequences within the file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>time.column</code></td>
<td>
<p>character string, name of the column with time/depth/rank data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exclude.columns</code></td>
<td>
<p>character string or character vector with column names in <code>sequences</code> to be excluded from the analysis.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>character string naming a distance metric. Valid entries are: "manhattan", "euclidean", "chi", and "hellinger". Invalid entries will throw an error.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagonal</code></td>
<td>
<p>boolean, if <code>TRUE</code>, diagonals are included in the computation of the least cost path. Defaults to <code>FALSE</code>, as the original algorithm did not include diagonals in the computation of the least cost path. If <code>paired.samples</code> is <code>TRUE</code>, then <code>diagonal</code> is irrelevant.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>paired.samples</code></td>
<td>
<p>boolean, if <code>TRUE</code>, the sequences are assumed to be aligned, and distances are computed for paired-samples only (no distance matrix required). Default value is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>same.time</code></td>
<td>
<p>boolean. If <code>TRUE</code>, samples in the sequences to compare will be tested to check if they have the same time/age/depth according to <code>time.column</code>. This argument is only useful when the user needs to compare two sequences taken at different sites but same time frames.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ignore.blocks</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function <code>leastCostPathNoBlocks</code> analyzes the least-cost path of the best solution, and removes blocks (straight-orthogonal sections of the least-cost path), which happen in highly dissimilar sections of the sequences, and inflate output psi values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parallel.execution</code></td>
<td>
<p>boolean, if <code>TRUE</code> (default), execution is parallelized, and serialized if <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>repetitions</code></td>
<td>
<p>integer, number of null psi values to obtain.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A list with two slots:
</p>

<ul>
<li> <p><em>psi</em>: a dataframe. The first two columns contain the names of the sequences being compared, the third column contains the real <code>psi</code> value, and the rest of the column contain <code>psi</code> values computed on permutated versions of the datasets.
</p>
</li>
<li> <p><em>p</em>: a dataframe. The first two columns are as above, the third column contains the probability of obtaining a <code>random psi</code> lower than the real <code>psi</code> by chance.
</p>
</li>
</ul>
<h3>Author(s)</h3>

<p>Blas Benito &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class="language-R">

#load data
data("sequencesMIS")

#prepare sequences
MIS.sequences &lt;- prepareSequences(
  sequences = sequencesMIS,
  grouping.column = "MIS",
  transformation = "hellinger"
  )

#execute workflow to compute psi
MIS.null.psi &lt;- workflowNullPsi(
 sequences = MIS.sequences[MIS.sequences$MIS %in% c("MIS-1", "MIS-2"), ],
 grouping.column = "MIS",
 method = "manhattan",
 repetitions = 3,
 parallel.execution = FALSE
 )

MIS.null.psi


</code></pre>


</div>