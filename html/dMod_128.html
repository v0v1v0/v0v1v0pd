<div class="container">

<table style="width: 100%;"><tr>
<td>obsfn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Observation function</h2>

<h3>Description</h3>

<p>An observation function is a function is that is concatenated
with a prediction function via prodfn to yield a new prediction function,
see prdfn. Observation functions are generated by Y. Handling
of the conditions is then organized by the <code>obsfn</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">obsfn(X2Y, parameters = NULL, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>X2Y</code></td>
<td>
<p>the low-level observation function generated e.g. by Y.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>character vector with parameter names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>character, the condition name</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Observation functions can be "added" by the "+" operator, see sumfn. Thereby,
observations for different conditions are merged or, overwritten. Observation functions can
also be concatenated with other functions, e.g. observation functions (obsfn) or
prediction functions (prdfn) by the "*" operator, see prodfn.
</p>


<h3>Value</h3>

<p>Object of class <code>obsfn</code>, i.e. a function <code>x(..., fixed, deriv, conditions, env)</code>
which returns a prdlist. The arguments <code>out</code> (prediction) and <code>pars</code> (parameter values)
should be passed via the <code>...</code> argument.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>


</div>