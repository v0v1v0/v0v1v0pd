<div class="container">

<table style="width: 100%;"><tr>
<td>penalty_control</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Options for penalty setup in the pre-processing</h2>

<h3>Description</h3>

<p>Options for penalty setup in the pre-processing
</p>


<h3>Usage</h3>

<pre><code class="language-R">penalty_control(
  defaultSmoothing = NULL,
  df = 10,
  null_space_penalty = FALSE,
  absorb_cons = FALSE,
  anisotropic = TRUE,
  zero_constraint_for_smooths = TRUE,
  no_linear_trend_for_smooths = FALSE,
  hat1 = FALSE,
  sp_scale = function(x) ifelse(is.list(x) | is.data.frame(x), 1/NROW(x[[1]]),
    1/NROW(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>defaultSmoothing</code></td>
<td>
<p>function applied to all s-terms, per default (NULL)
the minimum df of all possible terms is used. Must be a function the smooth term
from mgcv's smoothCon and an argument <code>df</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>degrees of freedom for all non-linear structural terms (default = 7);
either one common value or a list of the same length as number of parameters;
if different df values need to be assigned to different smooth terms,
use df as an argument for <code>s()</code>, <code>te()</code> or <code>ti()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>null_space_penalty</code></td>
<td>
<p>logical value;
if TRUE, the null space will also be penalized for smooth effects.
Per default, this is equal to the value give in <code>variational</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>absorb_cons</code></td>
<td>
<p>logical; adds identifiability constraint to the basis.
See <code>?mgcv::smoothCon</code> for more details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anisotropic</code></td>
<td>
<p>whether or not use anisotropic smoothing (default is TRUE)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zero_constraint_for_smooths</code></td>
<td>
<p>logical; the same as absorb_cons,
but done explicitly. If true a constraint is put on each smooth to have zero mean. Can
be a vector of <code>length(list_of_formulas)</code> for each distribution parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no_linear_trend_for_smooths</code></td>
<td>
<p>logical; see <code>zero_constraint_for_smooths</code>, but
this removes the linear trend from splines</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hat1</code></td>
<td>
<p>logical; if TRUE, the smoothing parameter is defined by the trace of the hat
matrix sum(diag(H)), else sum(diag(2*H-HH))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sp_scale</code></td>
<td>
<p>function of response; for scaling the penalty (1/n per default)</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>Returns a list with options
</p>


</div>