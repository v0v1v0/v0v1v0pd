<div class="container">

<table style="width: 100%;"><tr>
<td>DoubleMLIRM</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Double machine learning for interactive regression models</h2>

<h3>Description</h3>

<p>Double machine learning for interactive regression models.
</p>


<h3>Format</h3>

<p>R6::R6Class object inheriting from DoubleML.
</p>


<h3>Details</h3>

<p>Interactive regression (IRM) models take the form
</p>
<p><code class="reqn">Y = g_0(D,X) + U</code>,
</p>
<p><code class="reqn">D = m_0(X) + V</code>,
</p>
<p>with <code class="reqn">E[U|X,D]=0</code> and <code class="reqn">E[V|X] = 0</code>. <code class="reqn">Y</code> is the outcome variable
and <code class="reqn">D \in \{0,1\}</code> is the binary treatment variable. We consider
estimation of the average treamtent effects when treatment effects are
fully heterogeneous. Target parameters of interest in this model are the
average treatment effect (ATE),
</p>
<p><code class="reqn">\theta_0 = E[g_0(1,X) - g_0(0,X)]</code>
</p>
<p>and the average treament effect on the treated (ATTE),
</p>
<p><code class="reqn">\theta_0 = E[g_0(1,X) - g_0(0,X)|D=1]</code>.
</p>


<h3>Super class</h3>

<p><code>DoubleML::DoubleML</code> -&gt; <code>DoubleMLIRM</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>trimming_rule</code></dt>
<dd>
<p>(<code>character(1)</code>) <br>
A <code>character(1)</code> specifying the trimming approach.</p>
</dd>
<dt><code>trimming_threshold</code></dt>
<dd>
<p>(<code>numeric(1)</code>) <br>
The threshold used for timming.</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DoubleMLIRM-new"><code>DoubleMLIRM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DoubleMLIRM-clone"><code>DoubleMLIRM$clone()</code></a>
</p>
</li>
</ul>
<details><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="bootstrap"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-bootstrap"><code>DoubleML::DoubleML$bootstrap()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="confint"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-confint"><code>DoubleML::DoubleML$confint()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="fit"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-fit"><code>DoubleML::DoubleML$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="get_params"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-get_params"><code>DoubleML::DoubleML$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="learner_names"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-learner_names"><code>DoubleML::DoubleML$learner_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="p_adjust"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-p_adjust"><code>DoubleML::DoubleML$p_adjust()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="params_names"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-params_names"><code>DoubleML::DoubleML$params_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="print"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-print"><code>DoubleML::DoubleML$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="set_ml_nuisance_params"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-set_ml_nuisance_params"><code>DoubleML::DoubleML$set_ml_nuisance_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="set_sample_splitting"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-set_sample_splitting"><code>DoubleML::DoubleML$set_sample_splitting()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="split_samples"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-split_samples"><code>DoubleML::DoubleML$split_samples()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="summary"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-summary"><code>DoubleML::DoubleML$summary()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DoubleML" data-topic="DoubleML" data-id="tune"><a href="../../DoubleML/html/DoubleML.html#method-DoubleML-tune"><code>DoubleML::DoubleML$tune()</code></a></span></li>
</ul></details><hr>
<a id="method-DoubleMLIRM-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>Creates a new instance of this R6 class.
</p>


<h5>Usage</h5>

<div class="r"><pre>DoubleMLIRM$new(
  data,
  ml_g,
  ml_m,
  n_folds = 5,
  n_rep = 1,
  score = "ATE",
  trimming_rule = "truncate",
  trimming_threshold = 1e-12,
  dml_procedure = "dml2",
  draw_sample_splitting = TRUE,
  apply_cross_fitting = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt>
<dd>
<p>(<code>DoubleMLData</code>) <br>
The <code>DoubleMLData</code> object providing the data and specifying the variables
of the causal model.</p>
</dd>
<dt><code>ml_g</code></dt>
<dd>
<p>(<code>LearnerRegr</code>,
<code>LearnerClassif</code>, <code>Learner</code>,
<code>character(1)</code>) <br>
A learner of the class <code>LearnerRegr</code>, which is
available from <a href="https://mlr3.mlr-org.com/index.html">mlr3</a> or its
extension packages <a href="https://mlr3learners.mlr-org.com/">mlr3learners</a> or
<a href="https://mlr3extralearners.mlr-org.com/">mlr3extralearners</a>.
For binary treatment outcomes, an object of the class
<code>LearnerClassif</code> can be passed, for example
<code>lrn("classif.cv_glmnet", s = "lambda.min")</code>.
Alternatively, a <code>Learner</code> object with public field
<code>task_type = "regr"</code> or <code>task_type = "classif"</code> can be passed,
respectively, for example of class
<code>GraphLearner</code>. <br><code>ml_g</code> refers to the nuisance function <code class="reqn">g_0(X) = E[Y|X,D]</code>.</p>
</dd>
<dt><code>ml_m</code></dt>
<dd>
<p>(<code>LearnerClassif</code>,
<code>Learner</code>, <code>character(1)</code>) <br>
A learner of the class <code>LearnerClassif</code>, which is
available from <a href="https://mlr3.mlr-org.com/index.html">mlr3</a> or its
extension packages <a href="https://mlr3learners.mlr-org.com/">mlr3learners</a> or
<a href="https://mlr3extralearners.mlr-org.com/">mlr3extralearners</a>.
Alternatively, a <code>Learner</code> object with public field
<code>task_type = "classif"</code> can be passed, for example of class
<code>GraphLearner</code>. The learner can possibly
be passed with specified parameters, for example
<code>lrn("classif.cv_glmnet", s = "lambda.min")</code>. <br><code>ml_m</code> refers to the nuisance function <code class="reqn">m_0(X) = E[D|X]</code>.</p>
</dd>
<dt><code>n_folds</code></dt>
<dd>
<p>(<code>integer(1)</code>)<br>
Number of folds. Default is <code>5</code>.</p>
</dd>
<dt><code>n_rep</code></dt>
<dd>
<p>(<code>integer(1)</code>) <br>
Number of repetitions for the sample splitting. Default is <code>1</code>.</p>
</dd>
<dt><code>score</code></dt>
<dd>
<p>(<code>character(1)</code>, <code style="white-space: pre;">⁠function()⁠</code>) <br>
A <code>character(1)</code> (<code>"ATE"</code> or <code>ATTE</code>) or a <code style="white-space: pre;">⁠function()⁠</code> specifying the
score function. If a <code style="white-space: pre;">⁠function()⁠</code>
is provided, it must be of the form
<code style="white-space: pre;">⁠function(y, d, g0_hat, g1_hat, m_hat, smpls)⁠</code> and the returned output
must be a named <code>list()</code> with elements <code>psi_a</code> and <code>psi_b</code>.
Default is <code>"ATE"</code>.</p>
</dd>
<dt><code>trimming_rule</code></dt>
<dd>
<p>(<code>character(1)</code>) <br>
A <code>character(1)</code> (<code>"truncate"</code> is the only choice) specifying the
trimming approach. Default is <code>"truncate"</code>.</p>
</dd>
<dt><code>trimming_threshold</code></dt>
<dd>
<p>(<code>numeric(1)</code>) <br>
The threshold used for timming. Default is <code>1e-12</code>.</p>
</dd>
<dt><code>dml_procedure</code></dt>
<dd>
<p>(<code>character(1)</code>) <br>
A <code>character(1)</code> (<code>"dml1"</code> or <code>"dml2"</code>) specifying the double machine
learning algorithm. Default is <code>"dml2"</code>.</p>
</dd>
<dt><code>draw_sample_splitting</code></dt>
<dd>
<p>(<code>logical(1)</code>) <br>
Indicates whether the sample splitting should be drawn during
initialization of the object. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>apply_cross_fitting</code></dt>
<dd>
<p>(<code>logical(1)</code>) <br>
Indicates whether cross-fitting should be applied. Default is <code>TRUE</code>.</p>
</dd>
</dl>
</div>


<hr>
<a id="method-DoubleMLIRM-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DoubleMLIRM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>See Also</h3>

<p>Other DoubleML: 
<code>DoubleML</code>,
<code>DoubleMLIIVM</code>,
<code>DoubleMLPLIV</code>,
<code>DoubleMLPLR</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
library(DoubleML)
library(mlr3)
library(mlr3learners)
library(data.table)
set.seed(2)
ml_g = lrn("regr.ranger",
  num.trees = 100, mtry = 20,
  min.node.size = 2, max.depth = 5)
ml_m = lrn("classif.ranger",
  num.trees = 100, mtry = 20,
  min.node.size = 2, max.depth = 5)
obj_dml_data = make_irm_data(theta = 0.5)
dml_irm_obj = DoubleMLIRM$new(obj_dml_data, ml_g, ml_m)
dml_irm_obj$fit()
dml_irm_obj$summary()

## Not run: 
library(DoubleML)
library(mlr3)
library(mlr3learners)
library(mlr3uning)
library(data.table)
set.seed(2)
ml_g = lrn("regr.rpart")
ml_m = lrn("classif.rpart")
obj_dml_data = make_irm_data(theta = 0.5)
dml_irm_obj = DoubleMLIRM$new(obj_dml_data, ml_g, ml_m)

param_grid = list(
  "ml_g" = paradox::ps(
    cp = paradox::p_dbl(lower = 0.01, upper = 0.02),
    minsplit = paradox::p_int(lower = 1, upper = 2)),
  "ml_m" = paradox::ps(
    cp = paradox::p_dbl(lower = 0.01, upper = 0.02),
    minsplit = paradox::p_int(lower = 1, upper = 2)))

# minimum requirements for tune_settings
tune_settings = list(
  terminator = mlr3tuning::trm("evals", n_evals = 5),
  algorithm = mlr3tuning::tnr("grid_search", resolution = 5))
dml_irm_obj$tune(param_set = param_grid, tune_settings = tune_settings)
dml_irm_obj$fit()
dml_irm_obj$summary()

## End(Not run)

</code></pre>


</div>