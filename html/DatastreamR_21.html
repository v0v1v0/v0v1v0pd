<div class="container">

<table style="width: 100%;"><tr>
<td>TimeSeriesClient</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>TimeSeriesClient</h2>

<h3>Description</h3>

<p>This is the client class that manages the connection to the API server on your behalf.
It allows you to query for all your timeseries and to create/modify new timeseries.
</p>


<h3>Details</h3>

<p>Methods Supported <br>
GetAllItems : Allows you to query for all the current timeseries available for your use.<br>
GetItem : Allows you to download the details of a specific timeseries item.<br>
GetTimeseriesDateRange : Allows you to determine the supported timeseries dates between supplied start and
end dates at a specified frequency.<br>
CreateItem : Allows you to create a new timeseries item with up to 130 years of daily data.<br>
UpdateItem : Allows you to update an existing timeseries.<br>
DeleteItem : Allows you to delete an existing timeseries.<br></p>


<h3>Value</h3>

<p>TimeSeriesClient object
</p>


<h3>Super class</h3>

<p><code>DatastreamR::DSConnect</code> -&gt; <code>TimeSeriesClient</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>useNaNforNotANumber</code></dt>
<dd>
<p>If Enabled, NaN is appears in output response instead of NULL</p>
</dd>
<dt><code>TimeseriesResponseType</code></dt>
<dd>
<p>Response type</p>
</dd>
</dl>
</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TimeSeriesClient-new"><code>TimeSeriesClient$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.checkValidTimeseriesId"><code>TimeSeriesClient$.checkValidTimeseriesId()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.checkTimeSeriesReqValidity"><code>TimeSeriesClient$.checkTimeSeriesReqValidity()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.checkKeyTimeseriesProperties"><code>TimeSeriesClient$.checkKeyTimeseriesProperties()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.asGetAllResponse"><code>TimeSeriesClient$.asGetAllResponse()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.asGetResponse"><code>TimeSeriesClient$.asGetResponse()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.jsonRequestEncoder"><code>TimeSeriesClient$.jsonRequestEncoder()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-.jsonResponseDecoder"><code>TimeSeriesClient$.jsonResponseDecoder()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-GetAllItems"><code>TimeSeriesClient$GetAllItems()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-GetItem"><code>TimeSeriesClient$GetItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-CreateItem"><code>TimeSeriesClient$CreateItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-UpdateItem"><code>TimeSeriesClient$UpdateItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-DeleteItem"><code>TimeSeriesClient$DeleteItem()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-GetTimeseriesDateRange"><code>TimeSeriesClient$GetTimeseriesDateRange()</code></a>
</p>
</li>
<li> <p><a href="#method-TimeSeriesClient-clone"><code>TimeSeriesClient$clone()</code></a>
</p>
</li>
</ul>
<details open><summary>Inherited methods</summary><ul>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="CheckToken"><a href="../../DatastreamR/html/DSConnect.html#method-DSConnect-CheckToken"><code>DatastreamR::DSConnect$CheckToken()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="IsValid"><a href="../../DatastreamR/html/DSConnect.html#method-DSConnect-IsValid"><code>DatastreamR::DSConnect$IsValid()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="getJsonResponse"><a href="../../DatastreamR/html/DSConnect.html#method-DSConnect-getJsonResponse"><code>DatastreamR::DSConnect$getJsonResponse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="DatastreamR" data-topic="DSConnect" data-id="getToken"><a href="../../DatastreamR/html/DSConnect.html#method-DSConnect-getToken"><code>DatastreamR::DSConnect$getToken()</code></a></span></li>
</ul></details><hr>
<a id="method-TimeSeriesClient-new"></a>



<h4>Method <code>new()</code>
</h4>

<p>User details can be supplied from a config file or passed directly as parameters
in the constructor of the derived user object type class.
(See the DSConnect superclass for a description of the connection parameters required)
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$new(
  config = NULL,
  username = NULL,
  password = NULL,
  proxies = NULL,
  sslCer = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config</code></dt>
<dd>
<p>Configuration File path</p>
</dd>
<dt><code>username</code></dt>
<dd>
<p>Your Datastream Id</p>
</dd>
<dt><code>password</code></dt>
<dd>
<p>Your Password</p>
</dd>
<dt><code>proxies</code></dt>
<dd>
<p>Proxies if any</p>
</dd>
<dt><code>sslCer</code></dt>
<dd>
<p>Path to CA bundle certificates file</p>
</dd>
</dl>
</div>



<h5>Details</h5>

<p>Timeseries Properties: <br>
useNaNforNotANumber : Non-trading days are stored as double NaNs on Datastream, JSON protocol permits NaNs as valid numbers.
Thus, all the NULLs in the converted to NaNs in the JSON requests. Responses contain the NULLs, But this should be converted
to Nans for Plotting purposes. If you want to receive NaN float values, set useNaNforNotANumber to TRUE, any NULLs in the returned
array of float values will be converted to NaNs.
</p>



<h5>Returns</h5>

<p>TimeSeriesClient object
</p>


<hr>
<a id="method-TimeSeriesClient-.checkValidTimeseriesId"></a>



<h4>Method <code>.checkValidTimeseriesId()</code>
</h4>

<p>A helper method to check the timeseries Id
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.checkValidTimeseriesId(inputId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inputId</code></dt>
<dd>
<p>: Timeseries Id</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>NULL if Timeseries id is valid else error string
</p>


<hr>
<a id="method-TimeSeriesClient-.checkTimeSeriesReqValidity"></a>



<h4>Method <code>.checkTimeSeriesReqValidity()</code>
</h4>

<p>A helper method to check some of the mandatory fields of timeseries for its validity
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.checkTimeSeriesReqValidity(tsItem)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsItem</code></dt>
<dd>
<p>Timeseries Item</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>NULL if Timeseries id is valid else error string
</p>


<hr>
<a id="method-TimeSeriesClient-.checkKeyTimeseriesProperties"></a>



<h4>Method <code>.checkKeyTimeseriesProperties()</code>
</h4>

<p>A helper method to check the Timeseries properties
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.checkKeyTimeseriesProperties(tsItem)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tsItem</code></dt>
<dd>
<p>Timeseries Item</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>NULL if Timeseries id is valid else error string
</p>


<hr>
<a id="method-TimeSeriesClient-.asGetAllResponse"></a>



<h4>Method <code>.asGetAllResponse()</code>
</h4>

<p>A helper method which converts the JSON response to GetAllResponse Object
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.asGetAllResponse(jsonDict)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt>
<dd>
<p>JSON Response</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>DSUserObjectGetAllResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-.asGetResponse"></a>



<h4>Method <code>.asGetResponse()</code>
</h4>

<p>A helper method which converts the JSON response to GetResponse Object
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.asGetResponse(jsonDict)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonDict</code></dt>
<dd>
<p>JSON Response</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-.jsonRequestEncoder"></a>



<h4>Method <code>.jsonRequestEncoder()</code>
</h4>

<p>A helper method that reformats the raw request to JSON format
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.jsonRequestEncoder(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt>
<dd>
<p>Raw request</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>return JSON formatted list
</p>


<hr>
<a id="method-TimeSeriesClient-.jsonResponseDecoder"></a>



<h4>Method <code>.jsonResponseDecoder()</code>
</h4>

<p>A helper method that converts JSON Response to a given class response type
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$.jsonResponseDecoder(jsonResp, responseType)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jsonResp</code></dt>
<dd>
<p>JSON Response</p>
</dd>
<dt><code>responseType</code></dt>
<dd>
<p>GetResponse or GetAllResponse type</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>return DSUserObjectGetAllResponse or DSUserObjectGetResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-GetAllItems"></a>



<h4>Method <code>GetAllItems()</code>
</h4>

<p>This method returns all the current timeseries you can use in Datastream queries.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$GetAllItems()</pre></div>



<h5>Returns</h5>

<p>DSUserObjectGetAllResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-GetItem"></a>



<h4>Method <code>GetItem()</code>
</h4>

<p>GetItem returns the details for an individual timeseries.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$GetItem(itemId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>itemId</code></dt>
<dd>
<p>: a valid timeseries Id.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-CreateItem"></a>



<h4>Method <code>CreateItem()</code>
</h4>

<p>This method attempts to create the given DSTimeSeriesRequestObject via the API service
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$CreateItem(newItem, overWrite = FALSE, skipItemReturn = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newItem</code></dt>
<dd>
<p>A DSTimeSeriesRequestObject containing the data used for creating the Timeseries.</p>
</dd>
<dt><code>overWrite</code></dt>
<dd>
<p>If the given Timeseries Id already exists on the system, the create call will be rejected.
Set overWrite = True to overwrite the existing item with new Timeseries.</p>
</dd>
<dt><code>skipItemReturn</code></dt>
<dd>
<p>: Upon successful creation of an item, the server requests the new item from the mainframe
and returns it in the response object. For faster processing, set skipItemReturn = True to skip returning the
object in the response</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-UpdateItem"></a>



<h4>Method <code>UpdateItem()</code>
</h4>

<p>This method attempts to modify a timeseries item using the given DSTimeSeriesRequestObject via
the API service
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$UpdateItem(item, skipItemReturn = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>item</code></dt>
<dd>
<p>A DSTimeSeriesRequestObject containing the data used for creating the Timeseries.</p>
</dd>
<dt><code>skipItemReturn</code></dt>
<dd>
<p>Upon successful creation of an item, the server requests the new item from the
mainframe and returns it in the response object. For faster processing, set skipItemReturn = True to
skip returning the object in the response.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>DSUserObjectResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-DeleteItem"></a>



<h4>Method <code>DeleteItem()</code>
</h4>

<p>DeleteItem allows you to delete an existing timeseries
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$DeleteItem(itemId)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>itemId</code></dt>
<dd>
<p>a valid timeseries Id.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>No return value
</p>


<hr>
<a id="method-TimeSeriesClient-GetTimeseriesDateRange"></a>



<h4>Method <code>GetTimeseriesDateRange()</code>
</h4>

<p>This method allows you to determine the supported dates between supplied start and end dates
at a specified frequency.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$GetTimeseriesDateRange(
  startDate,
  endDate,
  frequency = DSUserObjectFrequency$Daily
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>startDate</code></dt>
<dd>
<p>A date specifying the beginning of the date range</p>
</dd>
<dt><code>endDate</code></dt>
<dd>
<p>A date specifying the end of the date range</p>
</dd>
<dt><code>frequency</code></dt>
<dd>
<p>A DSUserObjectFrequency enumeration defining if the frequency should be daily,
weekly, monthly, quarterly or yearly.</p>
</dd>
</dl>
</div>



<h5>Returns</h5>

<p>DSTimeSeriesDateRangeResponse object
</p>


<hr>
<a id="method-TimeSeriesClient-clone"></a>



<h4>Method <code>clone()</code>
</h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TimeSeriesClient$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt>
<dd>
<p>Whether to make a deep clone.</p>
</dd>
</dl>
</div>




<h3>Note</h3>

<p>: You need a Datastream ID which is permissioned to access the Datastream APIs. In addition, this ID also needs
to be permissioned to access the custom user object service. Attempting to access this service without these permissions
will result in a permission denied error response.
</p>
<p>: For Daily and Weekly frequencies, if the supplied startDate falls on a weekend or a trading holiday, the returned
starting date will be the first trading day before the given start date. If the supplied endDate falls on a weekend or a
trading holiday, the returned final date will be the last trading day before the given end date. For Weekly frequencies,
this will be the last date which matches the day of the week for the first returned start date.<br><br>
For Monthly, Quarterly and Yearly frequencies, the returned dates are always the 1st day of each month, quarter or year.
The returned start and end dates are always the 1st days of the requested  month, quarter or year that the given start
and end dates fall within.
</p>
<p>: For Daily and Weekly frequencies, if the supplied startDate falls on a weekend or a trading holiday, the returned
starting date will be the first trading day before the given start date. If the supplied endDate falls on a weekend or a
trading holiday, the returned final date will be the last trading day before the given end date. For Weekly frequencies,
this will be the last date which matches the day of the week for the first returned start date.<br><br>
For Monthly, Quarterly and Yearly frequencies, the returned dates are always the 1st day of each month, quarter or year.
The returned start and end dates are always the 1st days of the requested  month, quarter or year that the given start
and end dates fall within.
</p>


<h3>Examples</h3>

<pre><code class="language-R">{
 # first logon with your credentials.
 # Creating a TimeSeriesClient instance with your credentials
 # automatically logs on for you.

 timeseriesClient = TimeSeriesClient$new(NULL, 'YourID', 'YourPwd')

 # query for all your current timeseries items

 itemsResp = timeseriesClient$GetAllItems()
 if (!is.null(itemsResp))
 {
   if (itemsResp$ResponseStatus != DSUserObjectResponseStatus$UserObjectSuccess)
   {
     # Your Datastream Id might not be permissioned for managing
     # user created items on this API

     print(paste('GetAllItems failed with error ',
     names(DSUserObjectResponseStatus)[[itemsResp$ResponseStatus + 1]],
     ': ', itemsResp$ErrorMessage))

   }
   else if (!is.null(itemsResp$UserObjects) &amp; itemsResp$UserObjectsCount &gt; 0)
   {
     # You do have access to some timeseries
     # Here we just put the timeseries details into a dataframe and list them
     print(paste('GetAllItems returned', itemsResp$UserObjectsCount, 'timeseries items.'))
     df = data.frame()

     for (tsItem in itemsResp$UserObjects)
     {
      if (!is.null(tsItem))
      {
       rowdata = list(Id = tsItem$Id,
       LastModified = tsItem$LastModified,
       StartDate = ifelse(!is.null(tsItem$DateInfo),as.character(tsItem$DateInfo$StartDate),""),
       EndDate =ifelse(!is.null(tsItem$DateInfo),as.character(tsItem$DateInfo$EndDate), ""),
       Frequency = ifelse(!is.null(tsItem$DateInfo), tsItem$DateInfo$Frequency, 0),
       NoOfValues = ifelse(!is.null(tsItem$DateRange), tsItem$DateRange$ValuesCount , 0),
       Desc = tsItem$Description)
       df = rbind(df, rowdata)
      }
     }
     print(df)
  }
 }
 #Example to show how to GetItem
 # query for a specific timeseries

 tsName = 'TSZZZ001'
 tsResponse = timeseriesClient$GetItem(tsName)

 # You may want to put the timeseries request response handling into a common function.
 if (!is.null(tsResponse))
 {
   # Any request dealing with a single user created item returns a DSUserObjectResponse.
   # This has ResponseStatus property that indicates success or failure

   if (tsResponse$ResponseStatus != DSUserObjectResponseStatus$UserObjectSuccess)
   {
     print(paste('Request failed for timeseries', tsName, 'with error',
                   names(DSUserObjectResponseStatus)[[tsResponse$ResponseStatus+1]],
                   ':', tsResponse$ErrorMessage))
   }
   else if (!is.null(tsResponse$UserObject))
   {
     # The timeseries item won't be returned if you set SkipItem true
     # in CreateItem or UpdateItem

     # Here we simply display the timeseries data using a dataframe.

     tsItem = tsResponse$UserObject
     metadata = c (Id = tsItem$Id,
     Desc = tsItem$Description,
     LastModified = as.character(tsItem$LastModified),
     StartDate = ifelse (!is.null(tsItem$DateInfo), as.character(tsItem$DateInfo$StartDate), NULL),
     EndDate = ifelse(!is.null(tsItem$DateInfo),as.character(tsItem$DateInfo$EndDate), NULL),
     Frequency = ifelse(!is.null(tsItem$DateInfo),
     names(DSUserObjectFrequency)[[tsItem$DateInfo$Frequency + 1]], NULL),
     NoOfValues = ifelse(!is.null(tsItem$DateRange), tsItem$DateRange$ValuesCount , 0))

     df = data.frame(metadata)
     print(df)
     if (!is.null(tsItem$DateRange))
     {
       df = data.frame(Dates = sapply(tsItem$DateRange$Dates,
       FUN = function(x){ return (as.character(x)) }),
                         Values = sapply(tsItem$DateRange$Values,
                         FUN = function(x){ ifelse (is.null(x),
                         return (NA_character_ ), return (x) )} ))

       # Values if NULL, is printed as &lt;NA&gt; because, while
       # convertind list to vector either by using as.vector or sapply,
       # the NULL values in the list are deleted. and thus there will
       # be mismatch in no of rows and cannot be put in a dataframe

       print(df)

     }
   }
 }
}

</code></pre>


</div>