<div class="container">

<table style="width: 100%;"><tr>
<td>prdfn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Prediction function</h2>

<h3>Description</h3>

<p>A prediction function is a function <code>x(..., fixed, deriv, conditions)</code>.
Prediction functions are generated by Xs, Xf or Xd. For an example
see the last one.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prdfn(P2X, parameters = NULL, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>P2X</code></td>
<td>
<p>transformation function as being produced by Xs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>parameters</code></td>
<td>
<p>character vector with parameter names</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>condition</code></td>
<td>
<p>character, the condition name</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Prediction functions can be "added" by the "+" operator, see sumfn. Thereby,
predictions for different conditions are merged or overwritten. Prediction functions can
also be concatenated with other functions, e.g. observation functions (obsfn) or
parameter transformation functions (parfn) by the "*" operator, see prodfn.
</p>


<h3>Value</h3>

<p>Object of class <code>prdfn</code>, i.e. a function <code>x(..., fixed, deriv, conditions, env)</code>
which returns a prdlist. The arguments <code>times</code> and
<code>pars</code> (parameter values) should be passed via the <code>...</code> argument, in this order.
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times &lt;- 0:5
grid &lt;- data.frame(name = "A", time = times, row.names = paste0("p", times))
x &lt;- Xd(grid)

# Define an observable and an observation function
observables &lt;- eqnvec(Aobs = "s*A")
g &lt;- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars &lt;- attr(x, "parameters")
obspars &lt;- attr(g, "parameters")
innerpars &lt;- c(dynpars, obspars)

trafo &lt;- structure(innerpars, names = innerpars)
trafo_C1 &lt;- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 &lt;- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p &lt;- NULL
p &lt;- p + P(trafo = trafo_C1, condition = "C1")
p &lt;- p + P(trafo = trafo_C2, condition = "C2")

# Collect outer (overarching) parameters and 
# initialize with random values
outerpars &lt;- attr(p, "parameters")
pars &lt;- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
out1 &lt;- (x*p)(times, pars)
plot(out1)

# Predict observed states in addition to unobserved
out2 &lt;- (g*x*p)(times, pars)
plot(out2)
</code></pre>


</div>