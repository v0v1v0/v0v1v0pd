<div class="container">

<table style="width: 100%;"><tr>
<td>UnivarLebDecDistribution-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "UnivarLebDecDistribution"</h2>

<h3>Description</h3>

<p><code>UnivarLebDecDistribution</code>-class is a class to formalize
a Lebesgue decomposed distribution with a discrete and an
absolutely continuous part; it is a subclass to
class <code>UnivarMixingDistribution</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("UnivarLebDecDistribution", ...)</code>.
More frequently they are created via the generating function
<code>UnivarLebDecDistribution</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mixCoeff</code></dt>
<dd>
<p>Object of class <code>"numeric"</code>: a vector of length
2 of probabilities for the respective a.c. and discrete part of
the object</p>
</dd>
<dt><code>mixDistr</code></dt>
<dd>
<p>Object of class <code>"UnivarDistrList"</code>: a list of
univariate distributions containing the a.c. and discrete components; must be of
length 2; the first component must be of class <code>"AbscontDistribution"</code>,
the second of class <code>"DiscreteDistribution"</code>.</p>
</dd>
<dt><code>img</code></dt>
<dd>
<p>Object of class <code>"Reals"</code>: the space of the image of this distribution which has dimension 1
and the name "Real Space" </p>
</dd>
<dt><code>param</code></dt>
<dd>
<p>Object of class <code>"Parameter"</code>: the parameter of this distribution, having only the
slot name "Parameter of a discrete distribution" </p>
</dd>
<dt><code>r</code></dt>
<dd>
<p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt>
<dd>
<p>fixed to <code>NULL</code></p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>Object of class <code>"function"</code>: cumulative distribution function</p>
</dd>
<dt><code>q</code></dt>
<dd>
<p>Object of class <code>"function"</code>: quantile function</p>
</dd>
<dt><code>.withArith</code></dt>
<dd>
<p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt>
<dd>
<p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt>
<dd>
<p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt>
<dd>
<p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>Symmetry</code></dt>
<dd>
<p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
<dt><code>support</code></dt>
<dd>
<p>numeric vector — the support slot of the discrete part</p>
</dd>
<dt><code>gaps</code></dt>
<dd>
<p>(numeric) matrix or <code>NULL</code>; — the gaps slot of 
the absolutely continuous part</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"UnivarMixingDistribution"</code>, directly;
class <code>"UnivariateDistribution"</code> by class <code>"UnivarMixingDistribution"</code>
class <code>"Distribution"</code> by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>plot</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acPart</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acPart&lt;-</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discretePart</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discretePart&lt;-</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acWeight</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>acWeight&lt;-</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discreteWeight</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>discreteWeight&lt;-</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>p.ac</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code> accessor to 
slot <code>p</code> of <code>acPart(object)</code>, possibly weighted 
by <code>acWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> with default value 
<code>"cond"</code> which if it does not partially match 
(by <code>pmatch</code>) <code>"abs"</code>, returns exactly
slot <code>p</code> of <code>acPart(object)</code> else weighted by 
<code>acWeight(object)</code>.</p>
</dd>
<dt>d.ac</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code>accessor to 
slot <code>d</code> of the absolutely continuous part of
the distribution, possibly weighted by <code>acWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> which acts as the one
in <code>p.ac</code>.</p>
</dd>
<dt>q.ac</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code> accessor to 
slot <code>q</code> of <code>acPart(object)</code>.</p>
</dd>
<dt>r.ac</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code> accessor to 
slot <code>q</code> of <code>acPart(object)</code>.</p>
</dd>
<dt>p.discrete</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>p</code> of <code>discretePart(object)</code>, 
possibly weighted by <code>discreteWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> which acts 
as the one in <code>p.ac</code>.</p>
</dd>
<dt>d.discrete</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>d</code> of <code>discretePart(object)</code>, 
possibly weighted by <code>discreteWeight(object)</code>; 
it has an extra argument <code>CondOrAbs</code> which acts as 
the one in <code>p.ac</code>.</p>
</dd>
<dt>q.discrete</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>q</code> of <code>discretePart(object)</code>.</p>
</dd>
<dt>r.discrete</dt>
<dd>
<p><code>signature(object = "UnivarLebDecDistribution")</code> 
accessor to slot <code>r</code> of <code>discretePart(object)</code>.</p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "AffLinUnivarLebDecDistribution", to = "UnivarLebDecDistribution")</code>:
create a <code>"UnivarLebDecDistribution"</code> object from a <code>"AffLinUnivarLebDecDistribution"</code> object</p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "AbscontDistribution", to = "UnivarLebDecDistribution")</code>:
create a <code>"UnivarLebDecDistribution"</code> object from a <code>"AbscontDistribution"</code> object</p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "DiscreteDistribution", to = "UnivarLebDecDistribution")</code>:
create a <code>"UnivarLebDecDistribution"</code> object from a <code>"DiscreteDistribution"</code> object</p>
</dd>
<dt>Math</dt>
<dd>
<p><code>signature(x = "UnivarLebDecDistribution")</code>: application of a mathematical function, e.g. <code>sin</code> or <code>tan</code> to this discrete distribution
</p>

<ul>
<li> <p><code>abs</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>abs(x)</code>.
</p>
</li>
<li> <p><code>exp</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>exp(x)</code>.
</p>
</li>
<li> <p><code>sign</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>sign(x)</code>.
</p>
</li>
<li> <p><code>sign</code>: <code>signature(x = "AcDcLcDistribution")</code>:  exact image distribution of <code>sign(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "AcDcLcDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li>
<li> <p><code>log</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  (with optional further argument <code>base</code>, defaulting to <code>exp(1)</code>) exact image distribution of <code>log(x)</code>.
</p>
</li>
<li> <p><code>log10</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact image distribution of <code>log10(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "UnivarLebDecDistribution")</code>:  exact 
image distribution of <code>sqrt(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "AcDcLcDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li>
</ul>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution")</code>: application of ‘-’ to this distribution</p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: multiplication of this distribution
by an object of class ‘numeric’</p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: division of this distribution
by an object of class ‘numeric’</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: addition of this distribution
to an object of class ‘numeric’</p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code>: subtraction of an object of class ‘numeric’
from this distribution </p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code>: multiplication of this distribution
by an object of class ‘numeric’</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code>: addition of this distribution
to an object of class ‘numeric’</p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code>: subtraction of this distribution
from an object of class ‘numeric’</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "UnivarLebDecDistribution")</code>: Convolution of two Lebesgue
decomposed distributions. Result is again of class <code>"UnivarLebDecDistribution"</code>, but if option
<code>getdistrOption("withSimplify")</code> is <code>TRUE</code> it is piped through a call to <code>simplifyD</code>,
hence may also be of class <code>AbscontDistribution</code> or <code>DiscreteDistribution</code></p>
</dd>
</dl>
<p>.
</p>
<dl>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "UnivarLebDecDistribution")</code>: Convolution of two Lebesgue
decomposed distributions. The same applies as for the preceding item.</p>
</dd>
</dl>
<h3>Internal subclass "AffLinUnivarLebDecDistribution"</h3>

<p>To enhance accuracy of several functionals on distributions,
mainly from package <span class="pkg">distrEx</span>,  
there is an internally used (but exported) subclass 
<code>"AffLinUnivarLebDecDistribution"</code> which has extra slots 
<code>a</code>, <code>b</code> (both of class <code>"numeric"</code>),  and <code>X0</code> 
(of class <code>"UnivarLebDecDistribution"</code>), to capture the fact 
that the object has the same distribution as <code>a * X0 + b</code>. This is 
the class of the return value of methods 
</p>

<dl>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivarLebDecDistribution")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AffLinUnivarLebDecDistribution")</code></p>
</dd>
</dl>
<p>There also is a class union of <code>"AffLinAbscontDistribution"</code>,
<code>"AffLinDiscreteDistribution"</code>, <code>"AffLinUnivarLebDecDistribution"</code>
and called <code>"AffLinDistribution"</code>
which is used for functionals.
</p>


<h3>Internal virtual superclass "AcDcLcDistribution"</h3>

<p>As many operations should be valid no matter whether the operands
are of class <code>"AbscontDistribution"</code>,
<code>"DiscreteDistribution"</code>, or <code>"UnivarLebDecDistribution"</code>,
there is a class union of these classes called <code>"AcDcLcDistribution"</code>;
in particular methods for <code>"*"</code>, <code>"/"</code>, 
<code>"^"</code> (see operators-methods) and methods
<code>Minimum</code>, <code>Maximum</code>, <code>Truncate</code>, and
<code>Huberize</code>, and <code>convpow</code> are defined for this 
class union.   
</p>


<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>
</p>


<h3>See Also</h3>

<p><code>Parameter-class</code>
<code>UnivarMixingDistribution-class</code>
<code>DiscreteDistribution-class</code>
<code>AbscontDistribution-class</code>
<code>simplifyD</code>
<code>flat.LCD</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">wg &lt;- flat.mix(UnivarMixingDistribution(Unif(0,1),Unif(4,5),
               withSimplify=FALSE))
myLC &lt;- UnivarLebDecDistribution(discretePart=Binom(3,.3), acPart = wg,
          discreteWeight=.2)
myLC
p(myLC)(0.3)
r(myLC)(30)
q(myLC)(0.9)
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
acPart(myLC)
plot(myLC)
d.discrete(myLC)(2)
p.ac(myLC)(0)
acWeight(myLC)
plot(acPart(myLC))
plot(discretePart(myLC))
gaps(myLC)
support(myLC)
plot(as(Norm(),"UnivarLebDecDistribution"))
</code></pre>


</div>