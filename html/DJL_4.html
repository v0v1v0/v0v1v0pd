<div class="container">

<table style="width: 100%;"><tr>
<td>dm.ddf</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Distance measure using DDF</h2>

<h3>Description</h3>

<p>Implements <em>Chambers</em>' directional distance function (non-radial &amp; non-oriented measure).</p>


<h3>Usage</h3>

<pre><code class="language-R">dm.ddf(xdata, ydata, rts="crs", g=NULL, 
       wd=NULL, se=FALSE, sg="ssm", date=NULL, cv="convex", o=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>xdata</code></td>
<td>
<p>Input(s) vector (<em>n</em> by <em>m</em>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ydata</code></td>
<td>
<p>Output(s) vector (<em>n</em> by <em>s</em>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rts</code></td>
<td>
<p>Returns to scale assumption <br><code>"crs"  </code>Constant RTS (default) <br><code>"vrs"  </code>Variable RTS <br><code>"irs"  </code>Increasing RTS <br><code>"drs"  </code>Decreasing RTS
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>Directional vector indicating a measurement direction (<em>n</em> by <em>(m+s)</em>)<br>
By default (<code>NULL</code>), <code>xdata</code> &amp; <code>ydata</code> will be used</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>wd</code></td>
<td>
<p>Weak disposability vector indicating (an) undesirable output(s) (<em>1</em> by <em>s</em>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>se</code></td>
<td>
<p>Implements super-efficiency model alike <em>Anderson &amp; Peterson</em>'s model if <code>TRUE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sg</code></td>
<td>
<p>Employs second-stage optimization <br><code>"ssm"  </code>Slack-sum maximization (default) <br><code>"max"  </code>Date-sum maximization (only if <code>date</code> is defined) <br><code>"min"  </code>Date-sum minimization (only if <code>date</code> is defined)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>date</code></td>
<td>
<p>Production date (<em>n</em> by <em>1</em>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cv</code></td>
<td>
<p>Convexity assumption <br><code>"convex" </code>Convexity holds (default) <br><code>"fdh"    </code>Free disposal hull (this will override <code>rts</code>)
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>o</code></td>
<td>
<p>DMU index to calc. <code>NULL</code>(default) will calc for all</p>
</td>
</tr>
</table>
<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>$eff</code></td>
<td>
<p>Efficiency score</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$lambda</code></td>
<td>
<p>Intensity vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$mu</code></td>
<td>
<p>Secondary intensity vector for weak disposability under VRS</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$beta</code></td>
<td>
<p>Input reduction factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$gamma</code></td>
<td>
<p>Output augmentation factor</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$xslack</code></td>
<td>
<p>Input slack</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>$yslack</code></td>
<td>
<p>Output slack</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Dong-Joon Lim, PhD</p>


<h3>References</h3>

<p>Chambers, Robert G., Yangho Chung, and Rolf Fare. "Profit, directional distance functions, and Nerlovian efficiency." <em>Journal of optimization theory and applications</em> 98.2 (1998): 351~364.
</p>
<p>Fare, Rolf, and Shawna Grosskopf. "Directional distance functions and slacks-based measures of efficiency." <em>European journal of operational research</em> 200.1 (2010): 320~322.
</p>


<h3>See Also</h3>

<p><code>dm.ddf</code> Distance measure using DDF <br><code>dm.dea</code> Distance measure using DEA <br><code>dm.hdf</code> Distance measure using HDF <br><code>dm.sbm</code> Distance measure using SBM <br><code>dm.sf</code> Distance measure using SF
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Additive form directional distance function
  # ready
  x &lt;- matrix(c(5, 1, 4), ncol = 1)
  y &lt;- matrix(c(8, 3, 5, 6, 4, 1), ncol = 2)
  g &lt;- matrix(c(1), nrow = 3, ncol = 3) 
  w &lt;- matrix(c(1, 0), ncol = 2)
  # go
  dm.ddf(x, y, "crs", g, w)

# Multiplicative form directional distance function
  # ready
  g &lt;- cbind(x, y)
  # go
  dm.ddf(x, y, "crs", g, w)
</code></pre>


</div>