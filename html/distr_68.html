<div class="container">

<table style="width: 100%;"><tr>
<td>operators-methods</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Methods for operators +,-,*,/,... in Package distr</h2>

<h3>Description</h3>

<p>Arithmetics and unary mathematical transformations for distributions</p>


<h3>Arguments</h3>

<table><tr style="vertical-align: top;">
<td><code>e1,e2</code></td>
<td>
<p> objects of class <code>"UnivariateDistribution"</code> (or subclasses) or <code>"numeric"</code></p>
</td>
</tr></table>
<h3>Details</h3>

<p>Arithmetics as well as all functions from group <code>Math</code>, see <code>Math</code>
are provided for distributions; wherever possible exact expressions are used; else 
random variables are generated according to this transformation and subsequently the remaining
slots filled by <code>RtoDPQ</code>, <code>RtoDPQ.d</code></p>


<h3>Methods</h3>


<dl>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "missing")</code> unary operator; result again of class <code>"UnivariateDistribution"</code>; exact</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "Norm", e2 = "missing")</code> unary operator; result again of <code>"Norm"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> result again of class <code>"UnivariateDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code> result  of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "CompoundDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Cauchy", e2 = "numeric")</code> result again of class <code>"Cauchy"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "numeric")</code> result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Norm", e2 = "numeric")</code> result again of class <code>"Norm"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Unif", e2 = "numeric")</code> result again of class <code>"Unif"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Logis", e2 = "numeric")</code>  result again of class <code>"Logis"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code> is translated to  
<code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>; exact</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2= "ANY")</code>;exact</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> is translated to 
<code>e1 + (-e2)</code>; exact</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code> is translated to <code>(-e1) + e2</code>; exact</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "Beta")</code> if <code>ncp(e2)==0</code> and <code>e1 == 1</code>,
an exact (central) <code>Beta(shape1 = shape2(e2), shape2 = shape1(e2))</code> is returned, else
the default method is used; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> result again of class <code>"UnivariateDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "AbscontDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "LatticeDistribution", e2 = "numeric")</code> result  of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "CompoundDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "AffLinAbscontDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinAbscontDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinDiscreteDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "AffLinLatticeDistribution", e2 = "numeric")</code> result again of 
class <code>"AffLinLatticeDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "AffLinUnivarLebDecDistribution", e2 = "numeric")</code> result of 
class <code>"AffLinUnivarLebDecDistribution"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "DExp", e2 = "numeric")</code> if <code>abs(e2)&gt;0</code> result again of class <code>"DExp"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Exp", e2 = "numeric")</code> if <code>e2&gt;0</code> result again of class <code>"Exp"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "ExpOrGammaOrChisq", e2 = "numeric")</code> if <code>e1</code> is a Gamma distribution and <code>e2&gt;0</code> 
result of class <code>"Gammad"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Weibull", e2 = "numeric")</code> if <code>e2&gt;0</code> 
result of class <code>"Weibull"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Cauchy", e2 = "numeric")</code>  if <code>abs(e2)&gt;0</code> result again of class <code>"Cauchy"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "numeric")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Norm", e2 = "numeric")</code>  if <code>abs(e2)&gt;0</code> result again of class <code>"Norm"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Unif", e2 = "numeric")</code>  if <code>abs(e2)&gt;0</code> result again of class <code>"Unif"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Logis", e2 = "numeric")</code>  if <code>e2&gt;0</code> result again of class <code>"Logis"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Lnorm", e2 = "numeric")</code>  if <code>e2&gt;0</code> result again of class <code>"Lnorm"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "UnivariateDistribution")</code> is translated to 
<code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code>; exact</p>
</dd>
<dt><code>/</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "numeric")</code> is translated to <code>e1 * (1/e2)</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "UnivariateDistribution")</code>  result again of class 
<code>"UnivariateDistribution"</code>; is generated by simulations</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "UnivariateDistribution")</code> is translated to <code>(-e1) + (-e2)</code>; 
result again of class   <code>"UnivariateDistribution"</code>; is generated by simulations</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: both operands are coerced
to class <code>"UnivarLebDecDistribution"</code> and the corresponding method is used.
</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AbscontDistribution", e2 = "AbscontDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"AbscontDistribution"</code>; is generated by FFT</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AbscontDistribution", e2 = "DiscreteDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"AbscontDistribution"</code>; is generated by FFT</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "AbscontDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"AbscontDistribution"</code>; is generated by FFT</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "LatticeDistribution", e2 = "LatticeDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; 
if the larger lattice-width is an integer multiple of the smaller(in abs. value) one: result again of class 
<code>"LatticeDistribution"</code>; is generated by D/FFT</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "DiscreteDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"DiscreteDistribution"</code>; is generated by explicite convolution</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "LatticeDistribution", e2 = "DiscreteDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"DiscreteDistribution"</code>; is generated by explicite convolution</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "UnivarLebDecDistribution", e2 = "UnivarLebDecDistribution")</code> assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"UnivarLebDecDistribution"</code>; is generated by separate explicite convolution of a.c. and discrete parts of <code>e1</code> and <code>e2</code>
and subsequent flattening with <code>flat.LCD</code>; if <code>getdistrOption("withSimplify")</code> is  <code>TRUE</code>, result is piped
through a call to <code>simplifyD</code></p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: both operands are coerced
to class <code>"UnivarLebDecDistribution"</code> and the corresponding method is used.
</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Binom", e2 = "Binom")</code> assumes <code>e1</code>, <code>e2</code> independent; 
if <code>prob(e1)==prob(e2)</code>, result again of class 
<code>"Binom"</code>; uses the convolution formula for binomial distributions; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Cauchy", e2 = "Cauchy")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Cauchy"</code>; uses the convolution formula for Cauchy distributions; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Chisq", e2 = "Chisq")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Chisq"</code>; uses the convolution formula for Chisq distributions; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "Dirac")</code> result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "ExpOrGammaOrChisq", e2 = "ExpOrGammaOrChisq")</code>  assumes <code>e1</code>, <code>e2</code> independent; if 
<code>e1</code>, <code>e2</code> are Gamma distributions, result is of class 
<code>"Gammad"</code>; uses the convolution formula for Gamma distributions; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Pois", e2 = "Pois")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Pois"</code>; uses the convolution formula for Poisson distributions; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Nbinom", e2 = "Nbinom")</code>  assumes <code>e1</code>, <code>e2</code> independent; if 
<code>prob(e1)==prob(e2)</code>, result again of class 
<code>"Nbinom"</code>; uses the convolution formula for negative binomial distributions; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Norm", e2 = "Norm")</code>  assumes <code>e1</code>, <code>e2</code> independent; result again of class 
<code>"Norm"</code>; uses the convolution formula for normal distributions; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "Dirac")</code>  translated to <code>e1 + location(e2)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "UnivariateDistribution")</code>  translated to <code>e2 + location(e1)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>+</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "DiscreteDistribution")</code>  translated to <code>e2 + location(e1)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>-</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "UnivariateDistribution", e2 = "Dirac")</code>  translated to <code>e1 * location(e2)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "UnivariateDistribution")</code>  translated to <code>e2 * location(e1)</code>; 
result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>*</code></dt>
<dd>
<p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: by means of <code>decomposePM</code>
<code>e1</code> and <code>e2</code> are decomposed into positive and negative parts; of these, convolutions of the
corresponding logarithms are computed separately and finally <code>exp</code> is applied to them, again separately;
the resulting mixing components are then “flattened” to one object of class 
<code>UnivarLebDecDistribution</code> by <code>flat.LCD</code> which according to <code>getdistrOption(withSimplify)</code> 
gets piped through a call to <code>simplifyD</code>.
</p>
</dd>
<dt><code>/</code></dt>
<dd>
<p><code>signature(e1 = "Dirac", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>/</code></dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "Dirac")</code>  result again of class <code>"Dirac"</code>; exact</p>
</dd>
<dt><code>/</code></dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AcDcLcDistribution")</code>: if <code>d.discrete(e2)(0)*discreteWeight(e2)&gt;0</code>
throws an error (would give division by 0 with positive probability); else by means of <code>decomposePM</code>
<code>e2</code> is decomposed into positive and negative parts; then, similarly the result obtains as for 
<code>"*"(signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is “flattened” to one object of class 
<code>UnivarLebDecDistribution</code> by <code>flat.LCD</code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code>simplifyD</code>; exact..
</p>
</dd>
<dt><code>/</code></dt>
<dd>
<p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: translated to <code>e1 * (1/e2)</code>.
</p>
</dd>
<dt><code>^</code></dt>
<dd>
<p><code>signature(e1 = "AcDcLcDistribution", e2 = "Integer")</code>: if <code>e2=0</code> returns <code>Dirac(1)</code>;
if <code>e2=1</code> returns <code>e1</code>; if <code>e2&lt;0</code> translated to <code>(1/e1)^(-e2)</code>; exact. 
</p>
</dd>
<dt><code>^</code></dt>
<dd>
<p><code>signature(e1 = "AcDcLcDistribution", e2 = "numeric")</code>: if <code>e2</code> is integer uses preceding
item; else if <code>e1&lt; 0</code> with positive probability, throughs an error; else
the result obtains similarly to 
<code>"*"(signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is “flattened” to one object of class 
<code>UnivarLebDecDistribution</code> by <code>flat.LCD</code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code>simplifyD</code>; exact.
</p>
</dd>
<dt><code>^</code></dt>
<dd>
<p><code>signature(e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution")</code>: 
if <code>e1</code> is negative with positive probability, 
throws an error if <code>e2</code> is non-integer
with positive probability; if <code>e1</code> is 0 with positive probability
throws an error if <code>e2</code> is non-integer with positive probability. 
if  <code>e2</code> is integer with probability 1 uses 
<code>DiscreteDistribution(supp=e1^(Dirac(x))</code> for each <code>x</code> in <code>support(e2)</code>,
builds up a corresponding mixing distribution; the latter is “flattened” to one object of class 
<code>UnivarLebDecDistribution</code> by <code>flat.LCD</code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code>simplifyD</code>.
Else the result obtains similarly to <code>"*"(signature(e1 = "AcDcLcDistribution", 
                e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is “flattened” to one object of class 
<code>UnivarLebDecDistribution</code> by <code>flat.LCD</code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code>simplifyD</code>; exact.
</p>
</dd>
<dt><code>^</code></dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AcDcLcDistribution")</code>: 
if <code>e1</code> is negative, throws an error if <code>e2</code> is non-integer
with positive probability; if <code>e1</code> is 0 throws an error if
<code>e2</code> is non-integer with positive probability. 
if  <code>e2</code> is integer with probability 1 uses 
<code>DiscreteDistribution(supp=e1^support(e2), prob=discrete.d(supp))</code>
else the result obtains similarly to <code>"*"(signature(e1 = "AcDcLcDistribution", 
                e2 = "AcDcLcDistribution"))</code> by the exp-log trick
and is “flattened” to one object of class 
<code>UnivarLebDecDistribution</code> by <code>flat.LCD</code> and 
according to <code>getdistrOption(withSimplify)</code> is piped through
a call to <code>simplifyD</code>; exact.
</p>
</dd>
</dl>
<h3>References</h3>

<p>Ruckdeschel, P., Kohl, M.(2014):
General purpose convolution algorithm for distributions 
in S4-Classes by means of FFT. <em>J. Statist. Softw.</em>
<b>59</b>(4): 1-25.
</p>


<h3>See Also</h3>

<p><code>UnivariateDistribution-class</code>
<code>AbscontDistribution-class</code> <br><code>DiscreteDistribution-class</code>
<code>LatticeDistribution-class</code><br><code>Norm-class</code>
<code>Binom-class</code>
<code>Pois-class</code>
<code>Dirac-class</code><br><code>Cauchy-class</code>
<code>Gammad-class</code>
<code>Logis-class</code>
<code>Lnorm-class</code><br><code>Exp-class</code>
<code>Weibull-class</code>
<code>Nbinom-class</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">N &lt;- Norm(0,3)
P &lt;- Pois(4)
a &lt;- 3
N + a
N + P
N - a
a * N
a * P
N / a + sin( a * P - N)
N * P
N / N

## takes a little time
N ^ P

1.2 ^ N
abs(N) ^ 1.3
</code></pre>


</div>