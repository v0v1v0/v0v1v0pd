<div class="container">

<table style="width: 100%;"><tr>
<td>simBulkProfiles</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Simulate training and test pseudo-bulk RNA-Seq profiles</h2>

<h3>Description</h3>

<p>Simulate training and test pseudo-bulk RNA-Seq profiles using the cell
composition matrices generated by the <code>generateBulkCellMatrix</code>
function. The samples are generated under the assumption that the expression
level of the <code class="reqn">i</code> gene in the <code class="reqn">j</code> bulk sample is given by the sum of
the expression levels of the cell types <code class="reqn">X_{ijk}</code> that make them up
weighted by the proportions of these <code class="reqn">k</code> cell types in each sample. In
practice, as described in Torroja and Sanchez-Cabo, 2019, these profiles are
generated by summing a number of cells of different cell types determined by
proportions from a matrix of known cell composition. The number of simulated
pseudo-bulk RNA-Seq samples and the number of cells composing each sample are
determined by <code>generateBulkCellMatrix</code> (see Documentation)
<strong>Note:</strong> this step can be avoided by using the <code>on.the.fly</code>
argument in the <code>trainDDLSModel</code> function. See
Documentation for more information.
</p>


<h3>Usage</h3>

<pre><code class="language-R">simBulkProfiles(
  object,
  type.data = "both",
  pseudobulk.function = "AddRawCount",
  file.backend = NULL,
  compression.level = NULL,
  block.processing = FALSE,
  block.size = 1000,
  chunk.dims = NULL,
  threads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p><code>DigitalDLSorter</code> object with
<code>single.cell.real</code>/<code>single.cell.simul</code> and <code>prob.cell.types</code>
slots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type.data</code></td>
<td>
<p>Type of data to generate between <code>'train'</code>,
<code>'test'</code> or <code>'both'</code> (the last by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pseudobulk.function</code></td>
<td>
<p>Function used to build pseudo-bulk samples. It may
be: </p>
 <ul>
<li> <p><code>"MeanCPM"</code>: single-cell profiles (raw counts) are
transformed into CPMs and cross-cell averages are calculated. Then,
<code>log2(CPM + 1)</code> is calculated. </p>
</li>
<li> <p><code>"AddCPM"</code>: single-cell
profiles (raw counts) are transformed into CPMs and are added up across
cells. Then, log-CPMs are calculated. </p>
</li>
<li> <p><code>"AddRawCount"</code>:
single-cell profiles (raw counts) are added up across cells. Then, log-CPMs
are calculated.</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>file.backend</code></td>
<td>
<p>Valid file path to store the simulated single-cell
expression profiles as an HDF5 file (<code>NULL</code> by default). If provided,
the data is stored in HDF5 files used as back-end by using the
<span class="pkg">DelayedArray</span>, <span class="pkg">HDF5Array</span> and <span class="pkg">rhdf5</span> packages instead of
loading all data into RAM memory. This is suitable for situations where you
have large amounts of data that cannot be loaded into memory. Note that
operations on this data will be performed in blocks (i.e subsets of
determined size) which may result in longer execution times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>compression.level</code></td>
<td>
<p>The compression level used if <code>file.backend</code> is
provided. It is an integer value between 0 (no compression) and 9 (highest
and slowest compression). See
<code>?getHDF5DumpCompressionLevel</code> from the
<span class="pkg">HDF5Array</span> package for more information.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block.processing</code></td>
<td>
<p>Boolean indicating whether the data should be
simulated in blocks (only if <code>file.backend</code> is used, <code>FALSE</code> by
default). This functionality is suitable for cases where is not possible to
load all data into memory and it leads to larger execution times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block.size</code></td>
<td>
<p>Only if <code>block.processing = TRUE</code>. Number of
pseudo-bulk expression profiles that will be simulated in each iteration
during the process. Larger numbers result in higher memory usage but
shorter execution times. Set according to available computational resources
(1000 by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>chunk.dims</code></td>
<td>
<p>Specifies the dimensions that HDF5 chunk will have. If
<code>NULL</code>, the default value is a vector of two items: the number of
genes considered by <code>DigitalDLSorter</code> object during the
simulation, and a single sample to reduce read times in the following
steps. A larger number of columns written in each chunk can lead to longer
read times.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>threads</code></td>
<td>
<p>Number of threads used during the simulation of pseudo-bulk
samples (1 by default). Set according to computational resources and avoid
it if <code>block.size</code> will be used.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><span class="pkg">digitalDLSorteR</span> allows the use of HDF5 files as back-end to store the
resulting data using the <span class="pkg">DelayedArray</span> and <span class="pkg">HDF5Array</span> packages.
This functionality allows to work without keeping the data loaded into RAM,
which could be of vital importance during some computationally heavy steps
such as neural network training on RAM-limited machines. You must provide a
valid file path in the <code>file.backend</code> argument to store the resulting
file with the '.h5' extension. The data will be accessible from R without
being loaded into memory. This option slightly slows down execution times, as
subsequent transformations of the data will be done in blocks rather than
using all the data. We recommend this option according to the computational
resources available and the number of pseudo-bulk samples to be generated.
</p>
<p>Note that if you use the <code>file.backend</code> argument with
<code>block.processing = FALSE</code>, all pseudo-bulk profiles will be simulated
in one step and, therefore, loaded into RAM. Then, the data will be written
to an HDF5 file. To avoid the RAM collapse, pseudo-bulk profiles can be
simulated and written to HDF5 files in blocks of <code>block.size</code> size by
setting <code>block.processing = TRUE</code>.
</p>
<p>It is possible to avoid this step by using the <code>on.the.fly</code> argument in
the <code>trainDDLSModel</code> function. In this way, data is
generated 'on the fly' during the neural network training. For more details,
see <code>?trainDDLSModel</code>.
</p>


<h3>Value</h3>

<p>A <code>DigitalDLSorter</code> object with <code>bulk.simul</code>
slot containing a list with one or two entries (depending on selected
<code>type.data</code> argument): <code>'train'</code> and <code>'test'</code>. Each entry
contains a <code>SummarizedExperiment</code> object
with simulated bulk samples in the <code>assay</code> slot, sample names in the
<code>colData</code> slot and feature names in the <code>rowData</code> slot.
</p>


<h3>References</h3>

<p>Fischer B, Smith M and Pau, G (2020). rhdf5: R Interface to HDF5.
R package version 2.34.0.
</p>
<p>Pagès H, Hickey P and Lun A (2020). DelayedArray: A unified framework for
working transparently with on-disk and in-memory array-like datasets. R
package version 0.16.0.
</p>
<p>Pagès H (2020). HDF5Array: HDF5 backend for DelayedArray objects. R package
version 1.18.0.
</p>


<h3>See Also</h3>

<p><code>generateBulkCellMatrix</code>
<code>ProbMatrixCellTypes</code>
<code>trainDDLSModel</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">set.seed(123) # reproducibility
# simulated data
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(2)),
  from = c(1, 30),
  to = c(15, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 10,
  verbose = TRUE
)
DDLS &lt;- simBulkProfiles(DDLS, verbose = TRUE)

</code></pre>


</div>