<div class="container">

<table style="width: 100%;"><tr>
<td>internals_for_distr</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Internal functions of package distr</h2>

<h3>Description</h3>

<p>These functions are used internally by package distr.</p>


<h3>Usage</h3>

<pre><code class="language-R">.is.vector.lattice(x)
.is.consistent(lattice, support, eq.space = TRUE)
.make.lattice.es.vector(x)
.inArgs(arg, fct)
.isEqual(p0, p1, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7))
.isEqual01(x)
.isIn(p0, pmat, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7
                                          ))
.isInteger(x, tol = .Machine$double.eps)
.isNatural(x, tol = .Machine$double.eps)
.isNatural0(x, tol = .Machine$double.eps)
.setEqual(x, y, tol = 1e-7)
.presubs(inp, frompat, topat)
.makeD(object, argList,  stand = NULL, fac = NULL)
.makeP(object, argList,  sign = TRUE, correct = NULL, fac =
                 NULL, fac2 = NULL)
.makeQ(object, lastCall, sign = TRUE, Cont = TRUE)
.plusm(e1, e2, Dclass = "DiscreteDistribution")
.multm(e1, e2, Dclass = "DiscreteDistribution")
.notwithLArg(D)
.getObjName(i = 1)
.discretizeP(D, lower, upper, h)
.fm(x,f)
.fM(x,f)
.fM2(x,f)
.makeDd(x,y, yleft, yright)
.makePd(x,y, yleft, yright)
.makeQd(x,y, yleft, yright)
.makeQc(x,y, yleft, yright)
.makeDNew(x, dx, h = NULL, Cont = TRUE, standM = "sum")
.makePNew(x, dx, h = NULL, notwithLLarg = FALSE,
                      Cont = TRUE, myPf = NULL, pxl = NULL, pxu = NULL)
.makeQNew(x, px.l, px.u, notwithLLarg = FALSE, yL , yR, Cont = TRUE)
.mergegaps(gaps, support)
.mergegaps2(gaps1, gaps2)
.consolidategaps(gaps)
.pmixfun(mixDistr, mixCoeff, leftright = "right")
.dmixfun(mixDistr, mixCoeff, withStand = FALSE, supp = NULL)
.rmixfun(mixDistr, mixCoeff)
.qmixfun(mixDistr, mixCoeff, Cont = TRUE, pnew, gaps = NULL, leftright = "left")
.del0dmixfun(mixDistr)
.loupmixfun(mixDistr)
.ULC.cast(x)
.expm.d(e1)
.expm.c(e1)
.logm.d(e1)
.logm.c(e1)
.P2D (p, xx, ql, qu, ngrid = getdistrOption("DefaultNrGridPoints"))
.P2Q (p, xx, ql,qu, ngrid = getdistrOption("DefaultNrGridPoints"), 
                qL = -Inf, qU = Inf)
.D2P (d, xx, ql, qu,  ngrid = getdistrOption("DefaultNrGridPoints"))
.Q2P (q, ngrid = getdistrOption("DefaultNrGridPoints"))
.csimpsum(fx)
.primefun(f,x, nm = NULL)
.IssueWarn(Arith,Sim)
.List(list0)
.fillList(list0, len=length(list0))
.trunc.up(object, upper)
.trunc.low(object, lower)
.modifyqgaps(pfun, qfun, gaps, leftright = "left")
.DistrCollapse(support, prob, eps = getdistrOption("DistrResolution"))
.EuclidAlgo(n1,n2)
.getCommonWidth(x1,x2, tol=.Machine$double.eps)
.convDiscrDiscr(e1,e2)
.inWithTol(x,y,tol=.Machine$double.eps)
.panel.mingle(dots,element)
devNew(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a (numeric) vector, or (in case of <code>.ULC.cast</code>) an object of class <code>"AcDcLcDistribution"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>a (numeric) vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>f</code></td>
<td>
<p>in function <code>.primefun</code>: a function in one (numeric) argument; 
in functions <code>.fm</code>, <code>.fM</code>, <code>.fM2</code> a vector of function evaluations</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lattice</code></td>
<td>
<p>a lattice (of class <code>Lattice</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>support</code></td>
<td>
<p>a support vector / support vector of a univariate discrete distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eq.space</code></td>
<td>
<p>logical: shall we check for the support to be equally spaced?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>arg</code></td>
<td>
<p>a formal argument as character</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fct</code></td>
<td>
<p>a function</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p0,p1</code></td>
<td>
<p>(numeric) vectors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pmat</code></td>
<td>
<p>(matrix) a matrix with two columns where row-wise the left column
is smaller than the right one</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>an error tolerance (numeric)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e1</code></td>
<td>
<p>a distribution object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e2</code></td>
<td>
<p>a numeric</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>a distribution object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>argList</code></td>
<td>
<p>an (unevaluated) list of arguments passed to <code>m(object)</code>  
where  <code>m</code> is in <code>d,p,q</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>stand</code></td>
<td>
<p>factor for a (Lebesgue) density to integrate to 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sign</code></td>
<td>
<p>the sign of the second operand — for multiplication at 
the moment</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>correct</code></td>
<td>
<p>unevaluated R-code to correct for right-continuity 
(for multiplication with negative numerics at the moment)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac</code></td>
<td>
<p>factor to be multiplied with the return value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac2</code></td>
<td>
<p>factor to be added to the return value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lastCall</code></td>
<td>
<p>unevaluated R-Code —gives how the result of a call to 
<code>q(e1)</code> is further transformed</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Cont</code></td>
<td>
<p>logical: <code>TRUE</code> if <code>object</code> is continuous</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Dclass</code></td>
<td>
<p>character: name of distribution class</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>D</code></td>
<td>
<p>a distribution object</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i</code></td>
<td>
<p>an integer</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yleft, yright</code></td>
<td>
<p>extrapolation value beyond left/right endpoint of grid</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h</code></td>
<td>
<p>numeric: grid width</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>standM</code></td>
<td>
<p>standardization method — summation or integration</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>notwithLLarg</code></td>
<td>
<p>logical — can we use <code>log.p</code>, <code>lower.tail</code> 
arguments for <code>p,q</code>-methods of first operand?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dx</code></td>
<td>
<p>numeric: vector of cell-probabilities for the (discretized) 
distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>myPf</code></td>
<td>
<p>function with args <code>x,y, yleft, yright</code> 
(as <code>approxfun</code>): 
if given: replaces <code>approxfun</code> as interpolation method for 
continuos distributions</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pxl,pxu</code></td>
<td>
<p>numeric: if given vector of (lower/upper) cumulative 
probabilities</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>yL, yR</code></td>
<td>
<p>argmin / argmax of p()-method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>inp</code></td>
<td>
<p>either a language object or a character vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>frompat</code></td>
<td>
<p>vector of character strings containing regular expressions (or
character string for <code>fixed = TRUE</code>) to be matched in the
given character vector.  Coerced by <code>as.character</code> to a
character string if possible; (as argument <code>pattern</code> in 
<code>gsub</code> — but possibly of length &gt;1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>topat</code></td>
<td>
<p> a (vector of) replacement(s) for matched pattern in 
<code>.presubs</code>. 
Coerced to character if possible.  For <code>fixed = FALSE</code> this
can include backreferences <code>"\1"</code> to <code>"\9"</code> to 
parenthesized subexpressions of <code>pattern</code>.  For 
<code>perl = TRUE</code> only, it can
also contain <code>"\U"</code> or <code>"\L"</code> to convert the rest of the
replacement to upper or lower case; (as argument <code>replacement</code> 
in <code>gsub</code>— but possibly of length &gt;1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gaps,gaps1,gaps2</code></td>
<td>
<p>matrices <code>m</code> with two columns, 
such that <code>t(m)</code>, interpreted as vector, is ordered</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prob</code></td>
<td>
<p>probability vector for a univariate discrete distribution</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mixDistr</code></td>
<td>
<p>an object of class <code>UnivarDistrList</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mixCoeff</code></td>
<td>
<p>an object of class <code>numeric</code>; a probability vector</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>pnew</code></td>
<td>
<p>a function <code>function(q, lower.tail = TRUE, log.p = FALSE</code>
realizing slot <code>p</code> in a distribution object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>withStand</code></td>
<td>
<p>logical; if <code>TRUE</code> a standardization is made such
that the sum of the values of the result evaluated at argument <code>supp</code> is 1</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>supp</code></td>
<td>
<p>NULL or <code>numeric</code>; if <code>withStand</code> is <code>TRUE</code> used
to standardize such that the result is a probability density.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>p,pfun</code></td>
<td>
<p>slot <code>p</code> of an object of class <code>"AbscontDistribution"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>d</code></td>
<td>
<p>slot <code>d</code> of an object of class <code>"AbscontDistribution"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>q,qfun</code></td>
<td>
<p>slot <code>q</code> of an object of class <code>"AbscontDistribution"</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xx</code></td>
<td>
<p>a given grid of x-values for functions <code>p</code>, <code>d</code> to be
evaluated at</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ql,qu</code></td>
<td>
<p>lower and upper <code>getdistrOption("TruncQuantile")</code>-quantile of
the distribution; also, if argument <code>xx</code> is missing, left and right endpoint
of a regular grid of <code>ngrid</code> gridpoints to be used in place of <code>xx</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>qL,qU</code></td>
<td>
<p>argmin / argmax of p()-method</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ngrid</code></td>
<td>
<p>number of gridpoints</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fx</code></td>
<td>
<p>a vector of function evaluations multiplied by the gridwidth</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nm</code></td>
<td>
<p>an optional right asymptotic value</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Arith</code></td>
<td>
<p>logical; slot <code>.withArith</code> of a distribution object,
or logically-“any” of these slots in a collection of such objects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Sim</code></td>
<td>
<p>logical; slot <code>.withSim</code> of a distribution object,
or logically-“any” of these slots in a collection of such objects</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>list0</code></td>
<td>
<p>list, the elements of which are to be copied to a new list using
recycling if necessary</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>len</code></td>
<td>
<p>length of the list to be filled</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>lower truncation point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>upper truncation point</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>leftright</code></td>
<td>
<p>character; for slot <code>q</code>: if partially matched to <code>"right"</code> 
function will return the right continuous version, else
the left continuous version; for slot <code>p</code>: if partially 
matched to <code>"left"</code> the left continuous version, else
the right continuous version;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n1</code></td>
<td>
<p>integer argument for <code>.EuclidAlgo</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n2</code></td>
<td>
<p>integer argument for <code>.EuclidAlgo</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x1</code></td>
<td>
<p>width argument for <code>.getCommonWidth</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x2</code></td>
<td>
<p>width argument for <code>.getCommonWidth</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dots</code></td>
<td>
<p>the unevaluated <code>...</code> argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>element</code></td>
<td>
<p>the name of the item in the unevaluated <code>...</code> argument</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>arguments passed through to other functions</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>.is.vector.lattice</code> checks whether a given vector <code>x</code> is equally 
spaced.
<code>.is.consistent</code> checks whether a given support vector <code>support</code> is 
consistent to a given lattice <code>lattice</code> — with or without checking
if <code>support</code> is equally spaced.  <code>.make.lattice.es.vector</code> 
makes an object of class <code>Lattice</code> out of a given (equally spaced) vector 
<code>x</code>.
</p>
<p><code>.inArgs</code> checks whether an argument <code>arg</code> is a formal argument of 
<code>fct</code> — not vectorized.
</p>
<p><code>.isEqual</code> checks whether <code>p0</code> and <code>p1</code> are equal to given
tolerance.
<code>.isIn</code> checks whether <code>p0</code> lies in any of the intervals given by
matrix <code>pmat</code> to given tolerance.
<code>.isEqual01</code>(x) checks whether <code>x</code> is 0 or 1 to given tolerance. 
<code>.setEqual</code> sets all elements of x which are equal to some element of y 
up to tolerance tol, to exactly the respective element of y. 
</p>
<p><code>.notwithLArg</code> checks whether object <code>D</code> was generated by simulations 
or if its slots <code>p,q</code> do not have <code>lower.tail</code> arguments.
</p>
<p><code>.getObjName</code> returns the name of the object in the <code>i</code>th operand.
<code>.discretizeP</code> discretizes <code>D</code> to a grid of probabilities from 
<code>lower</code> to <code>upper</code> with width <code>h</code>.   
</p>
<p><code>.fm</code>, <code>.fM</code> return the smallest / biggest value in (0,1) such that
<code>f</code>(x) is finite; <code>.fM2</code> is a variant of <code>.fM</code> using a 
<code>lower.tail = FALSE</code> argument.
</p>
<p><code>.makeD</code>, <code>.makeP</code>, <code>.makeQ</code> generate slots <code>p,d,q</code> for
binary operations <code>e1 /op/ e2</code> for a distribution object <code>e1</code> 
and a numeric <code>e2</code> —for the moment only <code>/op/</code>'s 
<code>+,-,*,/</code> are implemented.
</p>
<p><code>.plusm</code>, <code>.multm</code> more specifically use <code>.makeD</code>, <code>.makeP</code>, 
<code>.makeQ</code> to generate slots <code>p,d,q</code> for <code>+</code>, <code>*</code>, 
respectively. 
</p>
<p><code>.makeDd</code>, <code>.makePd</code>, <code>.makeQd</code> provide discrete analogues to 
<code>approxfun</code> for interpolation at non grid-values 
</p>
<p><code>.makeQc</code> is an analogue to <code>makeQd</code> for absolutely continuous 
distributions using <code>approxfun</code>. 
</p>
<p><code>.makeDNew</code> generates slot <code>d</code> for a new distribution object.
In case of a discrete distribution it produces a step function with 
<code>stepfun</code> (using <code>.makeDd</code>) and standardizes to 1 by summation.
In case of a continuous distribution it produces a density function with 
<code>approxfun</code> and standardizes to 1 by integration if the latter fails,
it uses a trapezoid rule / summation for this purpose.
</p>
<p><code>.makePNew</code> generates slot <code>p</code> for a new distribution object.
In case of a discrete distribution it produces a step function from 
<code>cumsum</code> applied to <code>dx</code> —or from <code>pxl</code> if this is given, with 
<code>stepfun</code> (using <code>.makePd</code>). 
In case of a continuous distribution it produces a cdf with 
<code>approxfun</code>. In case of <code>RtoDPQ</code>, <code>approxfun</code> is replaced by
<code>myPf</code> which calls <code>ecdf</code> directly.
</p>
<p><code>.makeQNew</code> generates slot <code>q</code> for a new distribution object.
In case of a discrete distribution it produces a step function 
(using <code>.makeQd</code>). Special care is taken for left continuity...
In case of a continuous distribution it produces a quantile function with 
<code>approxfun</code>. 
</p>
<p><code>.isInteger</code>, <code>.isNatural</code>, and <code>.isNatural0</code> test for each 
coordinate of argument <code>x</code> whether it
is integer [natural / natural or 0] or not.
</p>
<p><code>.mergegaps</code> modifies the gaps matrix of an a.c. distribution according to
the support slot of a discrete distribution; if necessary, a gap interval
[a,b] is split into [a,c],[c,b] if <code>a&lt;c&lt;b</code>.
<code>.mergegaps2</code> merges two gap matrices of two a.c. distributions <code>X1</code> 
and <code>X2</code> such that in the intervals of the resulting gap matrix, 
neither <code>X1</code> nor <code>X2</code> carries mass.
<code>.consolidategaps</code> consolidates a gap matrix, i.e. joins adjacent 
gap intervals.  
</p>
<p><code>.pmixfun</code>, <code>.dmixfun</code>, <code>.rmixfun</code>, and <code>.qmixfun</code>
fill the slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of a corresponding mixing distribution according to the arguments
in <code>mixDistr</code>, <code>mixCoeff</code>.
</p>
<p><code>.loupmixfun</code> finds commun lower and upper bounds for the support of
the mixing distribution.
</p>
<p><code>.del0dmixfun</code> sets (if slot <code>d.ac</code> is not <code>NULL</code>) the return
value of slot function <code>d.ac</code> of <code>mixDistr</code> 
for argument <code>0</code> to <code>0</code>.
</p>
<p><code>.ULC.cast</code> coerces an object of class <code>"AcDcLcDistribution"</code> to
class <code>"UnivarLebDecDistribution"</code>, using <code>simplifyD</code>.
</p>
<p><code>.expm.d,.expm.c</code> for discrete, resp. a.c. argument <code>e1</code> fill the 
slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of the transformation <code>exp(e1)</code> exactly.
<code>.logm.d,.logm.c</code> for discrete, resp. a.c. argument <code>e1</code> fill the 
slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of the transformation <code>log(e1)</code> exactly.
</p>
<p>For objects of class <code>AbscontDistribution</code>,
<code>.P2D</code> and <code>.P2Q</code> reconstruct function slots <code>d</code> resp. 
<code>q</code> from function slot <code>p</code>
by means of function <code>D1ss</code> from package <span class="pkg">sfsmisc</span>;
and of function <code>.makeQNew</code>,  respectively. The other way round, 
<code>.D2P</code> and <code>.Q2P</code> reconstruct function slot <code>p</code> from 
from function slots  <code>d</code> resp. <code>q</code> 
by means of function <code>.makePNew</code> and explicite numeric inversion,  
respectively.
</p>
<p><code>.csimpsum</code> is used internally in <code>.makePNew</code> to produce
a primitive function out of function evaluations by means of vectorized
Simpson quadrature method, returning already the function values
of the prime function on a grid; it is to mimick the behaviour
of <code>cumsum</code>. <code>.primefun</code> is similar but more flexible and
produces the prime function as a function.
</p>
<p><code>.List</code> checks if argument already is a list, and if so leaves it as
it is, otherwise casts it to a list by a call to <code>list</code>.
</p>
<p><code>.fillList</code> fills a new list with the elements of a given list <code>list0</code>
until length <code>len</code> is reached using recycling if necessary.
Argument <code>list0</code> is cast to <code>list</code> by a call
to <code>.List</code> if necessary.
</p>
<p><code>.trunc.up</code>, <code>.trunc.low</code>  provide common routines for
classes <code>DiscreteDistribution</code> and <code>AbscontDistribution</code> for 
one-sided truncation, using (for slot <code>r</code>) Peter Dalgaard's clever 
log-tricks as indicated in 
<a href="https://stat.ethz.ch/pipermail/r-help/2008-September/174321.html">https://stat.ethz.ch/pipermail/r-help/2008-September/174321.html</a>.
</p>
<p><code>.modifyqgaps</code> modifies slot <code>q</code> for objects of class 
<code>AbscontDistribution</code> in the presence of gaps, i.e.; if slot
<code>gaps</code> is not <code>NULL</code>. If argument <code>leftright</code> does not
partially match <code>"right"</code> (default) returns the left continuous
version of the quantile function, else the right continuous one.
</p>
<p><code>.EuclidAlgo</code> computes the greatest common divisor of two integers by 
means of the Euclidean algorithm.
<code>.getCommonWidth</code> for two lattices with widths <code>x1</code> and <code>x2</code>
computes the smallest common lattice width for convolution.
<code>.convDiscrDiscr</code> computes the convolution of two discrete distributions by
brute force.
<code>.inWithTol</code> works like <code>%in%</code> but with a given tolerance.
</p>
<p><code>.panel.mingle</code> is used for mingling arguments <code>panel.first</code>,
<code>panel.last</code> in a plot; it returns the evaluated argument <code>element</code>
within dots, if it is a symbol; else if it can be interpreted as a call, and if
the top call is <code>list</code>, it returns a list of the items of the call to <code>list</code>,
unevaluated, and otherwise the unchanged argument.
</p>
<p><code>devNew</code> opens a new device. This function is for back compatibility
with R versions &lt; 2.8.0. To control the number of opened devices, when
<code>length(dev.list())&gt;20</code>, in interactive mode we ask the user to shut
some windows until <code>length(dev.list())&lt;=20</code>; in non-interactive mode
we shut the first 15 open devices (except for the first one) before opening
a new one.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.is.vector.lattice</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.is.consistent</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.notwithLArg</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.make.lattice.es.vector</code></td>
<td>
<p>an object of class <code>Lattice</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.inArgs</code></td>
<td>
<p><code>logical</code> (length 1).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.isIn, .isEqual,.isEqual01</code></td>
<td>
<p>vector of <code>logical</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fm,.fM, .fM2</code></td>
<td>
<p>a <code>numeric</code> of length 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.plusm,.multm</code></td>
<td>
<p>an object of class <code>DiscreteDistribution</code> or 
<code>AbscontDistribution</code> according to argument <code>DClass</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.getObjName</code></td>
<td>
<p><code>character</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.discretizeP</code></td>
<td>
<p><code>numeric</code> — the probabilities for the grid-values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.makeDd,.makePd, .makeQd</code></td>
<td>
<p>a function with args 
<code>x, y, yleft, yright</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.makeD,.makeDNew</code></td>
<td>
<p>a function with args <code>x, log = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.makeP,.makePNew</code></td>
<td>
<p>a function with args <code>q, lower.tail = TRUE, 
       log.p = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.makeQ,.makeQNew</code></td>
<td>
<p>a function with args <code>p, lower.tail = TRUE, 
       log.p = FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.isInteger,.isNatural,.isNatural0</code></td>
<td>
<p><code>logical</code> (same length as argument <code>x</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.mergegaps,.mergegaps2</code></td>
<td>
<p>a <code>gaps</code>-matrix, i.e.; a matrix <code>m</code> with two columns, 
such that <code>t(m)</code>, interpreted as vector, is ordered.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.pmixfun</code></td>
<td>
<p>slot <code>p</code> for a mixing distribution, i.e. a function 
<code>function(q, lower.tail = TRUE, log.p = FALSE)</code>, which
is  the cdf of the distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.dmixfun</code></td>
<td>
<p>slot <code>d</code> for a mixing distribution, i.e. a function 
<code>function(x, log = FALSE)</code>, which
is  the density of the distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.qmixfun</code></td>
<td>
<p>slot <code>q</code> for a mixing distribution, i.e. a function 
<code>function(p, lower.tail = TRUE, log.p = FALSE)</code>, which
is  the quantile function of the distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.rmixfun</code></td>
<td>
<p>slot <code>r</code> for a mixing distribution, i.e. a function 
<code>function(n)</code> generating r.v.'s according to the distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.deldmixfun</code></td>
<td>
<p>a possibly modified argument <code>mixDistr</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.loupmixfun</code></td>
<td>
<p>a list of four components: <code>qL</code>, the minimal value of 
<code>q(x)(0)</code>, <code>ql</code>, the minimal value of 
<code>q(x)(getdistrOption("TruncQuantile"))</code>, <code>qU</code>, the maximal value of 
<code>q(x)(1)</code>, <code>qu</code>, the maximal value of 
<code>q(x)(getdistrOption("TruncQuantile"), lower.tail = FALSE)</code>,
<code>x</code> running through the members of <code>mixDistr</code> in each case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.ULC.cast</code></td>
<td>
<p>an object of class <code>"UnivarLebDecDistribution"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.expm.d,.logm.d</code></td>
<td>
<p>an object of class <code>"DiscreteDistribution"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.expm.c,.logm.c</code></td>
<td>
<p>an object of class <code>"AbscontDistribution"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.P2D</code></td>
<td>
<p>a density <code>d</code> as function <code>function(x,  log = FALSE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.P2Q</code></td>
<td>
<p>a quantile function <code>q</code> as function <code>function(p, 
            lower.tail = TRUE, log.p = FALSE)</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.D2P, .Q2P</code></td>
<td>
<p>a cdf <code>p</code> as function <code>function(q, 
            lower.tail = TRUE, log.p = FALSE)</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.csimpsum</code></td>
<td>
<p>a vector of evaluations of the prime function at the grid points.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.primefun</code></td>
<td>
<p>the prime function as a function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.IssueWarn</code></td>
<td>
<p>a list with two warnings to be issued each of which may be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.List</code></td>
<td>
<p>a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.fillList</code></td>
<td>
<p>a list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.trunc.up,.trunc.low</code></td>
<td>
<p>a list with elements <code>r,p,d,q</code> (in this order).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.DistrCollapse</code></td>
<td>
<p>upon a suggestion by Jacob van Etten, 
<a href="mailto:jacobvanetten@yahoo.com">jacobvanetten@yahoo.com</a>: help function to collapse the support 
points of a discrete distributions if they are too close to each other;
here argument <code>support</code> is the (original; already sorted) support
and <code>prob</code> a corresponding probability vector of same length.
Criterium for collapsing: a distance smaller than argument
<code>eps</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.EuclidAlgo</code></td>
<td>
<p>returns the greatest common divisor (an integer).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.getCommonWidth</code></td>
<td>
<p>returns the  smallest common lattice width (a numeric).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.convDiscrDiscr</code></td>
<td>
<p>returns the convolution of two discrete distributions.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.inWithTol</code></td>
<td>
<p>returns a logical vector of same lenght as <code>x</code> for the
matches (up to tolerance) with vector <code>y</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.panel.mingle</code></td>
<td>
<p>used for mingling arguments <code>panel.first</code>,
<code>panel.last</code>; returns the evaluated argument <code>element</code> within dots,
if it is a symbol; else if it can be interpreted as a call, and if the top
call is <code>list</code>, it returns a list of the items of the call to <code>list</code>,
unevaluated, and otherwise the unchanged argument.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>devNew</code></td>
<td>
<p>returns the return value of the device opened,
usually invisible <code>NULL</code>.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code>AbscontDistribution</code>,
<code>DiscreteDistribution</code>,
<code>LatticeDistribution</code>,
<code>RtoDPQ</code>,
<code>RtoDPQ.d</code>,
<code>convpow</code>,
<code>operators</code>,
<code>plot-methods</code>
<code>dev.new</code>
</p>


</div>