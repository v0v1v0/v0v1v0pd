<div class="container">

<table style="width: 100%;"><tr>
<td>new_relational</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Relational implementer's interface</h2>

<h3>Description</h3>

<p>The constructor and generics described here define a class
that helps separating dplyr's user interface from the actual underlying operations.
In the longer term, this will help packages that implement the dplyr interface
(such as <span class="pkg">dbplyr</span>, <span class="pkg">dtplyr</span>, <span class="pkg">arrow</span> and similar)
to focus on the core details of their functionality,
rather than on the intricacies of dplyr's user interface.
</p>
<p><code>new_relational()</code> constructs an object of class <code>"relational"</code>.
Users are encouraged to provide the <code>class</code> argument.
The typical use case will be to create a wrapper function.
</p>
<p><code>rel_to_df()</code> extracts a data frame representation from a relational object,
to be used by <code>dplyr::collect()</code>.
</p>
<p><code>rel_filter()</code> keeps rows that match a predicate,
to be used by <code>dplyr::filter()</code>.
</p>
<p><code>rel_project()</code> selects columns or creates new columns,
to be used by <code>dplyr::select()</code>, <code>dplyr::rename()</code>,
<code>dplyr::mutate()</code>, <code>dplyr::relocate()</code>, and others.
</p>
<p><code>rel_aggregate()</code> combines several rows into one,
to be used by <code>dplyr::summarize()</code>.
</p>
<p><code>rel_order()</code> reorders rows by columns or expressions,
to be used by <code>dplyr::arrange()</code>.
</p>
<p><code>rel_join()</code> joins or merges two tables,
to be used by <code>dplyr::left_join()</code>, <code>dplyr::right_join()</code>,
<code>dplyr::inner_join()</code>, <code>dplyr::full_join()</code>, <code>dplyr::cross_join()</code>,
<code>dplyr::semi_join()</code>, and <code>dplyr::anti_join()</code>.
</p>
<p><code>rel_limit()</code> limits the number of rows in a table,
to be used by <code>utils::head()</code>.
</p>
<p><code>rel_distinct()</code> only keeps the distinct rows in a table,
to be used by <code>dplyr::distinct()</code>.
</p>
<p><code>rel_set_intersect()</code> returns rows present in both tables,
to be used by <code>intersect()</code>.
</p>
<p><code>rel_set_diff()</code> returns rows present in any of both tables,
to be used by <code>setdiff()</code>.
</p>
<p><code>rel_set_symdiff()</code> returns rows present in any of both tables,
to be used by <code>dplyr::symdiff()</code>.
</p>
<p><code>rel_union_all()</code> returns rows present in any of both tables,
to be used by <code>dplyr::union_all()</code>.
</p>
<p><code>rel_explain()</code> prints an explanation of the plan
executed by the relational object.
</p>
<p><code>rel_alias()</code> returns the alias name for a relational object.
</p>
<p><code>rel_set_alias()</code> sets the alias name for a relational object.
</p>
<p><code>rel_names()</code> returns the column names as character vector,
to be used by <code>colnames()</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">new_relational(..., class = NULL)

rel_to_df(rel, ...)

rel_filter(rel, exprs, ...)

rel_project(rel, exprs, ...)

rel_aggregate(rel, groups, aggregates, ...)

rel_order(rel, orders, ascending, ...)

rel_join(
  left,
  right,
  conds,
  join = c("inner", "left", "right", "outer", "cross", "semi", "anti"),
  join_ref_type = c("regular", "natural", "cross", "positional", "asof"),
  ...
)

rel_limit(rel, n, ...)

rel_distinct(rel, ...)

rel_set_intersect(rel_a, rel_b, ...)

rel_set_diff(rel_a, rel_b, ...)

rel_set_symdiff(rel_a, rel_b, ...)

rel_union_all(rel_a, rel_b, ...)

rel_explain(rel, ...)

rel_alias(rel, ...)

rel_set_alias(rel, alias, ...)

rel_names(rel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Reserved for future extensions, must be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p>Classes added in front of the <code>"relational"</code> base class.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel, rel_a, rel_b, left, right</code></td>
<td>
<p>A relational object.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exprs</code></td>
<td>
<p>A list of <code>"relational_relexpr"</code> objects to filter by,
created by <code>new_relexpr()</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>A list of expressions to group by.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregates</code></td>
<td>
<p>A list of expressions with aggregates to compute.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>orders</code></td>
<td>
<p>A list of expressions to order by.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ascending</code></td>
<td>
<p>A logical vector describing the sort order.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conds</code></td>
<td>
<p>A list of expressions to use for the join.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>join</code></td>
<td>
<p>The type of join.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>join_ref_type</code></td>
<td>
<p>The ref type of join.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The number of rows.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alias</code></td>
<td>
<p>the new alias</p>
</td>
</tr>
</table>
<h3>Value</h3>


<ul>
<li> <p><code>new_relational()</code> returns a new relational object.
</p>
</li>
<li> <p><code>rel_to_df()</code> returns a data frame.
</p>
</li>
<li> <p><code>rel_names()</code> returns a character vector.
</p>
</li>
<li>
<p> All other generics return a modified relational object.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">new_dfrel &lt;- function(x) {
  stopifnot(is.data.frame(x))
  new_relational(list(x), class = "dfrel")
}
mtcars_rel &lt;- new_dfrel(mtcars[1:5, 1:4])

rel_to_df.dfrel &lt;- function(rel, ...) {
  unclass(rel)[[1]]
}
rel_to_df(mtcars_rel)

rel_filter.dfrel &lt;- function(rel, exprs, ...) {
  df &lt;- unclass(rel)[[1]]

  # A real implementation would evaluate the predicates defined
  # by the exprs argument
  new_dfrel(df[seq_len(min(3, nrow(df))), ])
}

rel_filter(
  mtcars_rel,
  list(
    relexpr_function(
      "gt",
      list(relexpr_reference("cyl"), relexpr_constant("6"))
    )
  )
)

rel_project.dfrel &lt;- function(rel, exprs, ...) {
  df &lt;- unclass(rel)[[1]]

  # A real implementation would evaluate the expressions defined
  # by the exprs argument
  new_dfrel(df[seq_len(min(3, ncol(df)))])
}

rel_project(
  mtcars_rel,
  list(relexpr_reference("cyl"), relexpr_reference("disp"))
)

rel_order.dfrel &lt;- function(rel, exprs, ...) {
  df &lt;- unclass(rel)[[1]]

  # A real implementation would evaluate the expressions defined
  # by the exprs argument
  new_dfrel(df[order(df[[1]]), ])
}

rel_order(
  mtcars_rel,
  list(relexpr_reference("mpg"))
)

rel_join.dfrel &lt;- function(left, right, conds, join, ...) {
  left_df &lt;- unclass(left)[[1]]
  right_df &lt;- unclass(right)[[1]]

  # A real implementation would evaluate the expressions
  # defined by the conds argument,
  # use different join types based on the join argument,
  # and implement the join itself instead of relaying to left_join().
  new_dfrel(dplyr::left_join(left_df, right_df))
}

rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel)


rel_limit.dfrel &lt;- function(rel, n, ...) {
  df &lt;- unclass(rel)[[1]]

  new_dfrel(df[seq_len(n), ])
}

rel_limit(mtcars_rel, 3)

rel_distinct.dfrel &lt;- function(rel, ...) {
  df &lt;- unclass(rel)[[1]]

  new_dfrel(df[!duplicated(df), ])
}

rel_distinct(new_dfrel(mtcars[1:3, 1:4]))

rel_names.dfrel &lt;- function(rel, ...) {
  df &lt;- unclass(rel)[[1]]

  names(df)
}

rel_names(mtcars_rel)
</code></pre>


</div>