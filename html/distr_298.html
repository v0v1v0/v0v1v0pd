<div class="container">

<table style="width: 100%;"><tr>
<td>DiscreteDistribution-class</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Class "DiscreteDistribution"</h2>

<h3>Description</h3>

<p>The <code>DiscreteDistribution</code>-class is the mother-class of the class <code>LatticeDistribution</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to <code>new("DiscreteDistribution", ...)</code>, but more
easily is the use of the generating function <code>"DiscreteDistribution"</code>.
This generating function, from version 1.9 on, has been moved to this package from package <span class="pkg">distrEx</span>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>img</code></dt>
<dd>
<p>Object of class <code>"Reals"</code>: the space of the image of this distribution which has dimension 1
and the name "Real Space" </p>
</dd>
<dt><code>param</code></dt>
<dd>
<p>Object of class <code>"Parameter"</code>: the parameter of this distribution, having only the
slot name "Parameter of a discrete distribution" </p>
</dd>
<dt><code>r</code></dt>
<dd>
<p>Object of class <code>"function"</code>: generates random numbers</p>
</dd>
<dt><code>d</code></dt>
<dd>
<p>Object of class <code>"function"</code>: density/probability function</p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>Object of class <code>"function"</code>: cumulative distribution function</p>
</dd>
<dt><code>q</code></dt>
<dd>
<p>Object of class <code>"function"</code>: quantile function</p>
</dd>
<dt><code>.withArith</code></dt>
<dd>
<p>logical: used internally to issue warnings as to 
interpretation of arithmetics</p>
</dd>
<dt><code>.withSim</code></dt>
<dd>
<p>logical: used internally to issue warnings as to 
accuracy</p>
</dd>
<dt><code>.logExact</code></dt>
<dd>
<p>logical: used internally to flag the case where 
there are explicit formulae for the log version of density, cdf, and 
quantile function</p>
</dd>
<dt><code>.lowerExact</code></dt>
<dd>
<p>logical: used internally to flag the case where 
there are explicit formulae for the lower tail version of cdf and quantile 
function</p>
</dd>
<dt><code>.finSupport</code></dt>
<dd>
<p>logical: used internally to check whether the
true support is finite; in case <code>img</code> is one-dimensional, it is
of length 2 (left and right end).</p>
</dd>
<dt><code>Symmetry</code></dt>
<dd>
<p>object of class <code>"DistributionSymmetry"</code>;
used internally to avoid unnecessary calculations.</p>
</dd>
</dl>
<h3>Extends</h3>

<p>Class <code>"UnivariateDistribution"</code>, directly.<br>
Class <code>"Distribution"</code>, by class <code>"UnivariateDistribution"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt>
<dd>
<p><code>signature(.Object = "DiscreteDistribution")</code>: initialize method </p>
</dd>
<dt>coerce</dt>
<dd>
<p><code>signature(from = "DiscreteDistribution", 
                   to = "LatticeDistribution")</code>: coerce method to class <code>"LatticeDistribution"</code>
(checks if support is a lattice)</p>
</dd>
<dt>Math</dt>
<dd>
<p><code>signature(x = "DiscreteDistribution")</code>: application of a mathematical function, e.g. <code>sin</code> or <code>tan</code> to this discrete distribution
</p>

<ul>
<li> <p><code>abs</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>abs(x)</code>.
</p>
</li>
<li> <p><code>exp</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>exp(x)</code>.
</p>
</li>
<li> <p><code>sign</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>sign(x)</code>.
</p>
</li>
<li> <p><code>sqrt</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>sqrt(x)</code>.
</p>
</li>
<li> <p><code>log</code>: <code>signature(x = "DiscreteDistribution")</code>:  (with optional further argument <code>base</code>, defaulting to <code>exp(1)</code>) exact image distribution of <code>log(x)</code>.
</p>
</li>
<li> <p><code>log10</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>log10(x)</code>.
</p>
</li>
<li> <p><code>gamma</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>gamma(x)</code>.
</p>
</li>
<li> <p><code>lgamma</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>lgamma(x)</code>.
</p>
</li>
<li> <p><code>digamma</code>: <code>signature(x = "DiscreteDistribution")</code>:  exact image distribution of <code>digamma(x)</code>.
</p>
</li>
</ul>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution")</code>: application of ‘-’ to this discrete distribution</p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: multiplication of this discrete distribution
by an object of class ‘numeric’</p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: division of this discrete distribution
by an object of class ‘numeric’</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: addition of this discrete distribution
to an object of class ‘numeric’</p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code>: subtraction of an object of class ‘numeric’
from this discrete distribution </p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code>: multiplication of this discrete distribution
by an object of class ‘numeric’</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code>: addition of this discrete distribution
to an object of class ‘numeric’</p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code>: subtraction of this discrete distribution
from an object of class ‘numeric’</p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "DiscreteDistribution")</code>: Convolution of two discrete
distributions. The slots p, d and q are approximated on a common grid.</p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "DiscreteDistribution")</code>: Convolution of two discrete
distributions. The slots p, d and q are approximated on a common grid.</p>
</dd>
<dt>support</dt>
<dd>
<p><code>signature(object = "DiscreteDistribution")</code>: returns the support</p>
</dd>
<dt>p.l</dt>
<dd>
<p><code>signature(object = "DiscreteDistribution")</code>: returns the 
left continuous cumulative distribution function, i.e.; 
<code class="reqn">p.l(t) = P(object &lt; t)</code> </p>
</dd>
<dt>q.r</dt>
<dd>
<p><code>signature(object = "DiscreteDistribution")</code>: returns the 
right-continuous quantile function, i.e.; 
<code class="reqn">{\rm q.r}(s)=\sup\{t \,\big|\, P({\tt object}\ge t)\leq s\}</code></p>
</dd>
<dt>plot</dt>
<dd>
<p><code>signature(object = "DiscreteDistribution")</code>: plots density, cumulative distribution and quantile
function </p>
</dd>
</dl>
<h3>Internal subclass "AffLinDiscreteDistribution"</h3>

<p>To enhance accuracy of several functionals on distributions,
mainly from package <span class="pkg">distrEx</span>, from version 1.9 of this package on, 
there is an internally used (but exported) subclass 
<code>"AffLinDiscreteDistribution"</code> which has extra slots 
<code>a</code>, <code>b</code> (both of class <code>"numeric"</code>),  and <code>X0</code> 
(of class <code>"DiscreteDistribution"</code>), to capture the fact 
that the object has the same distribution as <code>a * X0 + b</code>. This is 
the class of the return value of methods 
</p>

<dl>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "DiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "DiscreteDistribution")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "AffLinDiscreteDistribution")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>/</dt>
<dd>
<p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "AffLinDiscreteDistribution", e2 = "numeric")</code></p>
</dd>
<dt>*</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AffLinDiscreteDistribution")</code></p>
</dd>
<dt>+</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AffLinDiscreteDistribution")</code></p>
</dd>
<dt>-</dt>
<dd>
<p><code>signature(e1 = "numeric", e2 = "AffLinDiscreteDistribution")</code></p>
</dd>
</dl>
<p>There also is a class union of <code>"AffLinAbscontDistribution"</code>,
<code>"AffLinDiscreteDistribution"</code>, <code>"AffLinUnivarLebDecDistribution"</code>
and called <code>"AffLinDistribution"</code>
which is used for functionals.
</p>


<h3>Internal virtual superclass "AcDcLcDistribution"</h3>

<p>As many operations should be valid no matter whether the operands
are of class <code>"AbscontDistribution"</code>,
<code>"DiscreteDistribution"</code>, or <code>"UnivarLebDecDistribution"</code>,
there is a class union of these classes called <code>"AcDcLcDistribution"</code>;
in partiucalar methods for <code>"*"</code>, <code>"/"</code>, 
<code>"^"</code> (see operators-methods) and methods
<code>Minimum</code>, <code>Maximum</code>, <code>Truncate</code>, and
<code>Huberize</code>, and <code>convpow</code> are defined for this 
class union.   
</p>


<h3>Note</h3>

<p> Working with a computer, we use a finite interval as support which 
carries at least mass <code>1-getdistrOption("TruncQuantile")</code>. <br></p>
<p>Also, we require that support points have distance at least       
<code>getdistrOption("DistrResoltion")</code>, if this condition fails,
upon a suggestion by Jacob van Etten, <a href="mailto:jacobvanetten@yahoo.com">jacobvanetten@yahoo.com</a>,
we use the global option <code>getdistrOption("DistrCollapse")</code> to
decide whether we use collapsing or not. If we do so, we collapse support 
points if they are too close to each other, taking
the (left most) median among them as new support point which accumulates
all the mass of the collapsed points. 
With <code>getdistrOption("DistrCollapse")==FALSE</code>, we at least collapse
points according to the result of <code>unique()</code>, and if after this
collapsing, the minimal distance is less than <code>getdistrOption("DistrResoltion")</code>,
we throw an error. By <code>getdistrOption("DistrCollapse.Unique.Warn")</code>,
we control, whether we throw a warning upon collapsing or not.       
</p>


<h3>Author(s)</h3>

<p>Thomas Stabla <a href="mailto:statho3@web.de">statho3@web.de</a>,<br> 
Florian Camphausen <a href="mailto:fcampi@gmx.de">fcampi@gmx.de</a>,<br>
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a>,<br> 
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p><code>Parameter-class</code>
<code>UnivariateDistribution-class</code>
<code>LatticeDistribution-class</code>
<code>AbscontDistribution-class</code>
<code>Reals-class</code>
<code>RtoDPQ.d</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># Dirac-measure at 0
D1 &lt;- DiscreteDistribution(supp = 0)
support(D1)

# simple discrete distribution
D2 &lt;- DiscreteDistribution(supp = c(1:5), prob = c(0.1, 0.2, 0.3, 0.2, 0.2))
plot(D2)
(pp &lt;- p(D2)(support(D2)))
p(D2)(support(D2)-1e-5)
p(D2)(support(D2)+1e-5)
p.l(D2)(support(D2))
p.l(D2)(support(D2)-1e-5)
p.l(D2)(support(D2)+1e-5)
q(D2)(pp)
q(D2)(pp-1e-5)
q(D2)(pp+1e-5)
## in RStudio or Jupyter IRKernel, use q.l(.)(.) instead of q(.)(.)
q.r(D2)(pp)
q.r(D2)(pp-1e-5)
q.r(D2)(pp+1e-5)
</code></pre>


</div>