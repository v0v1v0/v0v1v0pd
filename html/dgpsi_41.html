<div class="container">

<table style="width: 100%;"><tr>
<td>prune</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Static pruning of a DGP emulator</h2>

<h3>Description</h3>

<p>This function implements the static pruning of a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class="language-R">prune(object, control = list(), verb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>object</code></td>
<td>
<p>an instance of the <code>dgp</code> class that is generated by <code>dgp()</code> with <code>struc = NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>
<p>a list that can supply the following two components to control the static pruning of the DGP emulator:
</p>

<ul>
<li> <p><code>min_size</code>, the minimum number of design points required to trigger the pruning. Defaults to 10 times of the input dimensions.
</p>
</li>
<li> <p><code>threshold</code>, the R2 value above which a GP node is considered redundant and removable. Defaults to <code>0.97</code>.
</p>
</li>
</ul>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verb</code></td>
<td>
<p>a bool indicating if the trace information will be printed during the function execution. Defaults to <code>TRUE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> that could be an instance of <code>gp</code>, <code>dgp</code>, or <code>bundle</code> (of GP emulators) class.
</p>


<h3>Note</h3>


<ul>
<li>
<p> The function requires a DGP emulator that has been trained with a dataset comprising a minimum size equal to <code>min_size</code> in <code>control</code>.
If the training dataset size is smaller than this, it is suggested to enrich the design of the DGP emulator and prune its
structure dynamically using the <code>design()</code> function. Depending on the design of the DGP emulator, the static pruning may not be accurate.
It is thus suggested to implement dynamic pruning as a part of the sequential design via <code>design()</code>.
</p>
</li>
<li>
<p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code>validate()</code>; and
</p>
</li>
<li> <p><code>results</code> created by <code>predict()</code>;
</p>
</li>
</ul>
<p>in <code>object</code> will be removed and not contained in the returned object.
</p>
</li>
</ul>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 

# load the package and the Python env
library(dgpsi)

# construct the borehole function over a hypercube
f &lt;- function(x){
  x[,1] &lt;- (0.15 - 0.5) * x[,1] + 0.5
  x[,2] &lt;- exp((log(50000) - log(100)) * x[,2] + log(100))
  x[,3] &lt;- (115600 - 63070) *x[,3] + 63070
  x[,4] &lt;- (1110 - 990) * x[,4] + 990
  x[,5] &lt;- (116 - 63.1) * x[,5] + 63.1
  x[,6] &lt;- (820 - 700) * x[,6] + 700
  x[,7] &lt;- (1680 - 1120) * x[,7] + 1120
  x[,8] &lt;- (12045 - 9855) * x[,8] + 9855
  y &lt;- apply(x, 1, RobustGaSP::borehole)
}

# set a random seed
set_seed(999)

# generate training data
X &lt;- maximinLHS(80, 8)
Y &lt;- f(X)

# generate validation data
validate_x &lt;- maximinLHS(500, 8)
validate_y &lt;- f(validate_x)

# training a DGP emulator with anisotropic squared exponential kernels
m &lt;- dgp(X, Y, share = F)

# OOS validation of the DGP emulator
plot(m, validate_x, validate_y)

# prune the emulator until no more GP nodes are removable
m &lt;- prune(m)

# OOS validation of the resulting emulator
plot(m, validate_x, validate_y)

## End(Not run)
</code></pre>


</div>