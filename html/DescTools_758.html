<div class="container">

<table style="width: 100%;"><tr>
<td>Var</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Variance</h2>

<h3>Description</h3>

<p><code>Var()</code> computes the variance of <code>x</code>.  If <code>x</code> is a matrix variances of the columns of <code>x</code> are computed. <code>Varn</code> returns the uncorrected sample variance (which is biased estimator for the sample variance). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">
Var(x, ...)

## S3 method for class 'Freq'
Var(x, breaks, ...)

## Default S3 method:
Var(x, weights = NULL, na.rm = FALSE, method = c("unbiased",  "ML"), ...)

VarN(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a numeric vector, matrix or data frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>a numerical vector of weights the same length as <code>x</code> giving the weights to use for elements of <code>x</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>determines the estimator type; if <code>"unbiased"</code> (the default) then the usual unbiased estimate (using Bessel's correction) is returned, if <code>"ML"</code> then it is the maximum likelihood estimate for a Gaussian distribution. Uses stats:cov.wt for both methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>breaks</code></td>
<td>
<p>breaks for calculating the variance for classified data as composed by <code>Freq</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>Var</code> is just another interface to <code>Cov</code>.
</p>
<p>The denominator <code class="reqn">n - 1</code> is used which gives an unbiased estimator
of the (co)variance for i.i.d. observations.
These functions return <code>NA</code> when there is only one
observation (whereas S-PLUS has been returning <code>NaN</code>), and
fail if <code>x</code> has length zero.
</p>


<h3>Value</h3>

<p>For <code>r &lt;- Cor(*, use = "all.obs")</code>, it is now guaranteed that
<code>all(abs(r) &lt;= 1)</code>.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code>cor</code>, <code>cov</code> for covariance and correlation matrices
</p>
<p><code>cor.test</code> for confidence intervals (and tests).
</p>
<p><code>cov.wt</code> for <em>weighted</em> covariance computation.
</p>
<p><code>sd</code> for standard deviation (vectors).
</p>


<h3>Examples</h3>

<pre><code class="language-R">Var(1:10)  # 9.166667

Var(1:5, 1:5) # 2.5

# weighted Variance
set.seed(45)
(z &lt;- as.numeric(names(w &lt;- table(x &lt;- sample(-10:20, size=50, replace=TRUE)))))
Var(z, w=w)

# check!
all.equal(Var(x), Var(z, w=w))


# Variance for frequency tables
Var(Freq(as.table(c(6,16,24,25,17))),
     breaks=c(0, 10, 20, 30, 40, 50))
     
</code></pre>


</div>