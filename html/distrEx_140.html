<div class="container">

<table style="width: 100%;"><tr>
<td>HellingerDist</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Generic function for the computation of the Hellinger distance of two distributions</h2>

<h3>Description</h3>

<p>Generic function for the computation of the Hellinger distance <code class="reqn">d_h</code>
of two distributions <code class="reqn">P</code> and <code class="reqn">Q</code> which may be defined for an arbitrary 
sample space <code class="reqn">(\Omega,{\cal A})</code>. The Hellinger distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_h(P,Q)=\frac{1}{2}\int|\sqrt{dP}\,-\sqrt{dQ}\,|^2</code>
</p>

<p>where <code class="reqn">\sqrt{dP}</code>, respectively <code class="reqn">\sqrt{dQ}</code> denotes the square root 
of the densities.
</p>


<h3>Usage</h3>

<pre><code class="language-R">HellingerDist(e1, e2, ...)
## S4 method for signature 'AbscontDistribution,AbscontDistribution'
HellingerDist(e1,e2, 
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,DiscreteDistribution'
HellingerDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,AbscontDistribution'
HellingerDist(e1,e2, ...)
## S4 method for signature 'DiscreteDistribution,DiscreteDistribution'
HellingerDist(e1,e2, ...)
## S4 method for signature 'numeric,DiscreteDistribution'
HellingerDist(e1, e2, ...)
## S4 method for signature 'DiscreteDistribution,numeric'
HellingerDist(e1, e2, ...)
## S4 method for signature 'numeric,AbscontDistribution'
HellingerDist(e1, e2, asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e2),
            up.discr = getUp(e2), h.smooth = getdistrExOption("hSmooth"),
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AbscontDistribution,numeric'
HellingerDist(e1, e2, asis.smooth.discretize = "discretize", 
            n.discr = getdistrExOption("nDiscretize"), low.discr = getLow(e1),
            up.discr = getUp(e1), h.smooth = getdistrExOption("hSmooth"), 
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
## S4 method for signature 'AcDcLcDistribution,AcDcLcDistribution'
HellingerDist(e1,e2, 
                        rel.tol=.Machine$double.eps^0.3, 
                        TruncQuantile = getdistrOption("TruncQuantile"), 
                        IQR.fac = 15, ..., diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>e1</code></td>
<td>
<p> object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>e2</code></td>
<td>
<p> object of class <code>"Distribution"</code> or class <code>"numeric"</code> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>asis.smooth.discretize</code></td>
<td>
<p> possible methods are <code>"asis"</code>, 
<code>"smooth"</code> and <code>"discretize"</code>. Default is <code>"discretize"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the number of lattice points 
used to discretize the abs. cont. distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>low.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the lower end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>up.discr</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"discretize"</code> one has to specify the upper end point of the lattice 
used to discretize the abs. cont. distribution.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>h.smooth</code></td>
<td>
<p> if <code>asis.smooth.discretize</code> is equal to 
<code>"smooth"</code> – i.e., the empirical distribution of the provided 
data should be smoothed – one has to specify this parameter.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rel.tol</code></td>
<td>
<p> relative accuracy requested in integration </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>TruncQuantile</code></td>
<td>
<p>Quantile the quantile based integration bounds (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>IQR.fac</code></td>
<td>
<p>Factor for the scale based integration bounds (see details)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p> further arguments to be used in particular methods – (in package <span class="pkg">distrEx</span>: just
used for distributions with a.c. parts, where it is used to pass on arguments
to <code>distrExIntegrate</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>diagnostic</code></td>
<td>
<p> logical; if <code>TRUE</code>, the return value obtains
an attribute <code>"diagnostic"</code> with diagnostic information on the
integration, i.e., a list with entries <code>method</code> (<code>"integrate"</code>
or <code>"GLIntegrate"</code>), <code>call</code>, <code>result</code> (the complete return
value of the method),  <code>args</code> (the args with which the
method was called), and <code>time</code> (the time to compute the integral). </p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>For distances between absolutely continuous distributions, we use numerical
integration; to determine sensible bounds we proceed as follows:
by means of <code>min(getLow(e1,eps=TruncQuantile),getLow(e2,eps=TruncQuantile))</code>, 
<code>max(getUp(e1,eps=TruncQuantile),getUp(e2,eps=TruncQuantile))</code> we determine
quantile based bounds <code>c(low.0,up.0)</code>, and by means of
<code>s1 &lt;- max(IQR(e1),IQR(e2));</code> <code>m1&lt;- median(e1);</code> 
<code>m2 &lt;- median(e2)</code>
and <code>low.1 &lt;- min(m1,m2)-s1*IQR.fac</code>, <code>up.1 &lt;- max(m1,m2)+s1*IQR.fac</code>
we determine scale based bounds; these are combined by
<code>low &lt;- max(low.0,low.1)</code>, <code>up &lt;- max(up.0,up1)</code>.
</p>
<p>In case we want to compute the Hellinger distance between (empirical) data
and an abs. cont. distribution, we can specify the parameter <code>asis.smooth.discretize</code>
to avoid trivial distances (distance = 1).
</p>
<p>Using <code>asis.smooth.discretize = "discretize"</code>, which is the default,
leads to a discretization of the provided abs. cont. distribution and 
the distance is computed between the provided data and the discretized
distribution.
</p>
<p>Using <code>asis.smooth.discretize = "smooth"</code> causes smoothing of the
empirical distribution of the provided data. This is, the empirical
data is convoluted with the normal distribution <code>Norm(mean = 0, sd = h.smooth)</code>
which leads to an abs. cont. distribution. Afterwards the distance 
between the smoothed empirical distribution and the provided abs. cont.
distribution is computed.
</p>
<p>Diagnostics on the involved integrations are available if argument
<code>diagnostic</code> is <code>TRUE</code>. Then there is attribute <code>diagnostic</code>
attached to the return value, which may be inspected
and accessed through <code>showDiagnostic</code> and
<code>getDiagnostic</code>.
</p>


<h3>Value</h3>

<p> Hellinger distance of <code>e1</code> and <code>e2</code> </p>


<h3>Methods</h3>


<dl>
<dt>e1 = "AbscontDistribution", e2 = "AbscontDistribution":</dt>
<dd>
<p>Hellinger distance of two absolutely continuous 
univariate distributions which is computed using <code>distrExintegrate</code>.
</p>
</dd>
<dt>e1 = "AbscontDistribution", e2 = "DiscreteDistribution":</dt>
<dd>
<p>Hellinger distance of absolutely continuous and discrete
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = "DiscreteDistribution", e2 = "DiscreteDistribution":</dt>
<dd>
<p>Hellinger distance of two discrete univariate distributions
which is computed using <code>support</code> and <code>sum</code>.
</p>
</dd>
<dt>e1 = "DiscreteDistribution", e2 = "AbscontDistribution":</dt>
<dd>
<p>Hellinger distance of discrete and absolutely continuous 
univariate distributions (are mutually singular; i.e., 
have distance <code>=1</code>).
</p>
</dd>
<dt>e1 = "numeric", e2 = "DiscreteDistribution":</dt>
<dd>
<p>Hellinger distance between (empirical) data and a discrete 
distribution.
</p>
</dd>
<dt>e1 = "DiscreteDistribution", e2 = "numeric":</dt>
<dd>
<p>Hellinger distance between (empirical) data and a discrete
distribution.
</p>
</dd>
<dt>e1 = "numeric", e2 = "AbscontDistribution":</dt>
<dd>
<p>Hellinger distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = "AbscontDistribution", e1 = "numeric":</dt>
<dd>
<p>Hellinger distance between (empirical) data and an abs. cont. 
distribution.
</p>
</dd>
<dt>e1 = "AcDcLcDistribution", e2 = "AcDcLcDistribution":</dt>
<dd>
<p>Hellinger distance of mixed discrete and absolutely continuous 
univariate distributions.
</p>
</dd>
</dl>
<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>,<br>
Peter Ruckdeschel <a href="mailto:peter.ruckdeschel@uni-oldenburg.de">peter.ruckdeschel@uni-oldenburg.de</a></p>


<h3>References</h3>

<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code>distrExIntegrate</code>, <code>ContaminationSize</code>, 
<code>TotalVarDist</code>, <code>KolmogorovDist</code>, 
<code>Distribution-class</code></p>


<h3>Examples</h3>

<pre><code class="language-R">HellingerDist(Norm(), UnivarMixingDistribution(Norm(1,2),Norm(0.5,3),
                 mixCoeff=c(0.2,0.8)))
HellingerDist(Norm(), Td(10))
HellingerDist(Norm(mean = 50, sd = sqrt(25)), Binom(size = 100)) # mutually singular
HellingerDist(Pois(10), Binom(size = 20)) 

x &lt;- rnorm(100)
HellingerDist(Norm(), x)
HellingerDist(x, Norm(), asis.smooth.discretize = "smooth")

y &lt;- (rbinom(50, size = 20, prob = 0.5)-10)/sqrt(5)
HellingerDist(y, Norm())
HellingerDist(y, Norm(), asis.smooth.discretize = "smooth")

HellingerDist(rbinom(50, size = 20, prob = 0.5), Binom(size = 20, prob = 0.5))
</code></pre>


</div>