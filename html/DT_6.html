<div class="container">

<table style="width: 100%;"><tr>
<td>datatable</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create an HTML table widget using the DataTables library</h2>

<h3>Description</h3>

<p>This function creates an HTML widget to display rectangular data (a matrix or
data frame) using the JavaScript library DataTables.
</p>


<h3>Usage</h3>

<pre><code class="language-R">datatable(
  data,
  options = list(),
  class = "display",
  callback = JS("return table;"),
  rownames,
  colnames,
  container,
  caption = NULL,
  filter = c("none", "bottom", "top"),
  escape = TRUE,
  style = "auto",
  width = NULL,
  height = NULL,
  elementId = NULL,
  fillContainer = getOption("DT.fillContainer", NULL),
  autoHideNavigation = getOption("DT.autoHideNavigation", NULL),
  selection = c("multiple", "single", "none"),
  extensions = list(),
  plugins = NULL,
  editable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>a data object (either a matrix or a data frame)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>options</code></td>
<td>
<p>a list of initialization options (see
<a href="https://datatables.net/reference/option/">https://datatables.net/reference/option/</a>); the character options
wrapped in <code>JS()</code> will be treated as literal
JavaScript code instead of normal character strings; you can also set
options globally via <code>options(DT.options = list(...))</code>, and
global options will be merged into this <code>options</code> argument if set</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>class</code></td>
<td>
<p>the CSS class(es) of the table; see
<a href="https://datatables.net/manual/styling/classes">https://datatables.net/manual/styling/classes</a></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callback</code></td>
<td>
<p>the body of a JavaScript callback function with the argument
<code>table</code> to be applied to the DataTables instance (i.e. <code>table</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rownames</code></td>
<td>
<p><code>TRUE</code> (show row names) or <code>FALSE</code> (hide row names)
or a character vector of row names; by default, the row names are displayed
in the first column of the table if exist (not <code>NULL</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>colnames</code></td>
<td>
<p>if missing, the column names of the data; otherwise it can be
an unnamed character vector of names you want to show in the table header
instead of the default data column names; alternatively, you can provide a
<em>named</em> numeric or character vector of the form <code>'newName1' = i1,
'newName2' = i2</code> or <code>c('newName1' = 'oldName1', 'newName2' =
'oldName2', ...)</code>, where <code>newName</code> is the new name you want to show in
the table, and <code>i</code> or <code>oldName</code> is the index of the current
column name</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>container</code></td>
<td>
<p>a sketch of the HTML table to be filled with data cells; by
default, it is generated from <code>htmltools::tags$table()</code> with a table
header consisting of the column names of the data</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>caption</code></td>
<td>
<p>the table caption; a character vector or a tag object
generated from <code>htmltools::tags$caption()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter</code></td>
<td>
<p>whether/where to use column filters; <code>none</code>: no filters;
<code>bottom/top</code>: put column filters at the bottom/top of the table; range
sliders are used to filter numeric/date/time columns, select lists are used
for factor columns, and text input boxes are used for character columns; if
you want more control over the styles of filters, you can provide a named
list to this argument; see Details for more</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>escape</code></td>
<td>
<p>whether to escape HTML entities in the table: <code>TRUE</code> means
to escape the whole table, and <code>FALSE</code> means not to escape it;
alternatively, you can specify numeric column indices or column names to
indicate which columns to escape, e.g. <code>1:5</code> (the first 5 columns),
<code>c(1, 3, 4)</code>, or <code>c(-1, -3)</code> (all columns except the first and
third), or <code>c('Species', 'Sepal.Length')</code>; since the row names take
the first column to display, you should add the numeric column indices by
one when using <code>rownames</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>style</code></td>
<td>
<p>either <code>'auto'</code>, <code>'default'</code>, <code>'bootstrap'</code>, or
<code>'bootstrap4'</code>. If <code>'auto'</code>, and a **bslib** theme is
currently active, then bootstrap styling is used in a way that "just works"
for the active theme. Otherwise,
<a href="https://datatables.net/manual/styling/classes">DataTables
<code>'default'</code> styling</a> is used. If set explicitly to <code>'bootstrap'</code>
or <code>'bootstrap4'</code>, one must take care to ensure Bootstrap's HTML
dependencies (as well as Bootswatch themes, if desired) are included on the
page. Note, when set explicitly, it's the user's responsibility to ensure
that only one unique 'style' value is used on the same page, if multiple
DT tables exist, as different styling resources may conflict with each other.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>width, height</code></td>
<td>
<p>Width/Height in pixels (optional, defaults to automatic
sizing)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>elementId</code></td>
<td>
<p>An id for the widget (a random string by default).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fillContainer</code></td>
<td>
<p><code>TRUE</code> to configure the table to automatically fill
it's containing element. If the table can't fit fully into it's container
then vertical and/or horizontal scrolling of the table cells will occur.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoHideNavigation</code></td>
<td>
<p><code>TRUE</code> to automatically hide navigational UI
(only display the table body) when the number of total records is less
than the page size. Note, it only works on the client-side processing mode
and the 'pageLength' option should be provided explicitly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection</code></td>
<td>
<p>the row/column selection mode (single or multiple selection
or disable selection) when a table widget is rendered in a Shiny app;
alternatively, you can use a list of the form <code>list(mode = 'multiple',
selected = c(1, 3, 8), target = 'row', selectable = c(-2, -3))</code> to
pre-select rows and control the selectable range; the element
<code>target</code> in the list can be <code>'column'</code> to enable column
selection, or <code>'row+column'</code> to make it possible to select both rows
and columns (click on the footer to select columns), or <code>'cell'</code> to
select cells. See details section for more info.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>extensions</code></td>
<td>
<p>a character vector of the names of the DataTables
extensions (<a href="https://datatables.net/extensions/index">https://datatables.net/extensions/index</a>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plugins</code></td>
<td>
<p>a character vector of the names of DataTables plug-ins
(<a href="https://rstudio.github.io/DT/plugins.html">https://rstudio.github.io/DT/plugins.html</a>).  Note that only those
plugins supported by the <code>DT</code> package can be used here. You can see
the available plugins by calling <code>DT:::available_plugins()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>editable</code></td>
<td>
<p><code>FALSE</code> to disable the table editor, or <code>TRUE</code> (or
<code>"cell"</code>) to enable editing a single cell. Alternatively, you can set
it to <code>"row"</code> to be able to edit a row, or <code>"column"</code> to edit a
column, or <code>"all"</code> to edit all cells on the current page of the table.
In all modes, start editing by doubleclicking on a cell. This argument can
also be a list of the form <code>list(target = TARGET, disable =
list(columns = INDICES))</code>, where <code>TARGET</code> can be <code>"cell"</code>,
<code>"row"</code>, <code>"column"</code>, or <code>"all"</code>, and <code>INDICES</code> is an
integer vector of column indices. Use the list form if you want to disable
editing certain columns. You can also restrict the editing to accept only
numbers by setting this argument to a list of the form <code>list(target =
TARGET, numeric = INDICES)</code> where <code>INDICES</code> can be the vector of the
indices of the columns for which you want to restrict the editing to
numbers or <code>"all"</code> to restrict the editing to numbers for all columns.
If you don't set <code>numeric</code>, then the editing is restricted to numbers
for all numeric columns; set <code>numeric = "none"</code> to disable this
behavior. It is also possible to edit the cells in text areas, which are
useful for large contents. For that, set the <code>editable</code> argument to a
list of the form <code>list(target = TARGET, area = INDICES)</code> where
<code>INDICES</code> can be the vector of the indices of the columns for which
you want the text areas, or <code>"all"</code> if you want the text areas for
all columns. Of course, you can request the numeric editing for some
columns and the text areas for some other columns by setting
<code>editable</code> to a list of the form <code>list(target = TARGET, numeric
= INDICES1, area = INDICES2)</code>. Finally, you can edit date cells with a
calendar with <code>list(target = TARGET, date = INDICES)</code>; the target
columns must have the <code>Date</code> type. If you don't set <code>date</code> in
the <code>editable</code> list, the editing with the calendar is automatically
set for all <code>Date</code> columns.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>selection</code>:
</p>

<ol>
<li>
<p> The argument could be a scalar string, which means the selection
<code>mode</code>, whose value could be one of  <code>'multiple'</code> (the default),
<code>'single'</code> and <code>'none'</code> (disable selection).
</p>
</li>
<li>
<p> When a list form is provided for this argument, only parts of the
"full" list are allowed. The default values for non-matched elements are
<code>list(mode = 'multiple', selected = NULL, target = 'row',
      selectable = NULL)</code>.
</p>
</li>
<li> <p><code>target</code> must be one of <code>'row'</code>, <code>'column'</code>,
<code>'row+column'</code> and <code>'cell'</code>.
</p>
</li>
<li> <p><code>selected</code> could be <code>NULL</code> or "indices".
</p>
</li>
<li> <p><code>selectable</code> could be <code>NULL</code>, <code>TRUE</code>, <code>FALSE</code>
or "indices", where <code>NULL</code> and <code>TRUE</code> mean all the table is
selectable. When <code>FALSE</code>, it means users can't select the table
by the cursor (but they could still be able to select the table via
<code>dataTableProxy</code>, specifying <code>ignore.selectable = TRUE</code>).
If "indices", they must be all positive or non-positive values. All
positive "indices" mean only the specified ranges are selectable while all
non-positive "indices" mean those ranges are <em>not</em> selectable.
The "indices"' format is specified below.
</p>
</li>
<li>
<p> The "indices"' format of <code>selected</code> and <code>selectable</code>:
when <code>target</code> is <code>'row'</code> or <code>'column'</code>, it should be a plain
numeric vector; when <code>target</code> is <code>'row+column'</code>, it should be a
list, specifying <code>rows</code> and <code>cols</code> respectively, e.g.,
<code>list(rows = 1, cols = 2)</code>; when <code>target</code> is <code>'cell'</code>,
it should be a 2-col <code>matrix</code>, where the two values of each row
stand for the row and column index.
</p>
</li>
<li>
<p> Note that DT has its own selection implementation and doesn't
use the Select extension because the latter doesn't support the
server-side processing mode well. Please set this argument to
<code>'none'</code> if you really want to use the Select extension.
</p>
</li>
</ol>
<p><code>options$columnDefs</code>:
</p>

<ol>
<li> <p><code>columnDefs</code> is an option that provided by the DataTables library
itself, where the user can set various attributes for columns. It must be
provided as a list of list, where each sub-list must contain a vector named 'targets',
specifying the applied columns, i.e.,
<code>list(list(..., targets = '_all'), list(..., targets = c(1, 2)))</code>
</p>
</li>
<li> <p><code>columnDefs$targets</code> is a vector and should be one of:
</p>

<ul>
<li>
<p> 0 or a positive integer: column index counting from the left.
</p>
</li>
<li>
<p> A negative integer: column index counting from the right.
</p>
</li>
<li>
<p> A string: the column name. Note, it must be the names of the
original data, not the ones that (could) be changed via param <code>colnames</code>.
</p>
</li>
<li>
<p> The string "_all": all columns (i.e. assign a default).
</p>
</li>
</ul>
</li>
<li>
<p> When conflicts happen, e.g., a single column is defined for some property
twice but with different values, the value that defined earlier takes the priority.
For example, <code>list(list(visible=FALSE, target=1), list(visible=TRUE, target=1))</code>
results in a table whose first column is <em>invisible</em>.
</p>
</li>
<li>
<p> See <a href="https://datatables.net/reference/option/columnDefs">https://datatables.net/reference/option/columnDefs</a> for more.
</p>
</li>
</ol>
<p><code>filter</code>:
</p>

<ol>
<li> <p><code>filter</code> can be used to position and customize column filters.
A scalar string value defines the position, and must be one of <code>'none'</code>
(the default), <code>'bottom'</code> and <code>'top'</code>. A named list can be used
for further control. In the named list form:
</p>
</li>
<li> <p><code>$position</code> is a string as described above. It defaults to <code>'none'</code>.
</p>
</li>
<li> <p><code>$clear</code> is a logical value indicating if clear
buttons should appear in input boxes. It defaults to <code>TRUE</code>.
</p>
</li>
<li> <p><code>$plain</code> is a logical value indicating if plain styling
should be used for input boxes instead of Bootstrap styling. It
defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>$vertical</code> is a logical value indicating if slider
widgets should be oriented vertically rather than horizontally.
It defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>$opacity</code> is a numeric value between 0 and 1 used to set
the level of transparency of slider widgets. It defaults to <code>1</code>.
</p>
</li>
<li> <p><code>$settings</code> is a named list used to directly pass configuration
for initializing filter widgets in JavaScript.
</p>

<ul>
<li>
<p> The <code>$select</code> element is passed to the select widget, and
<code>$slider</code> is passed to the slider widget.
</p>
</li>
<li>
<p> Valid values depend on the settings accepted by the underlying
JavaScript libraries, <a href="https://selectize.dev/">Selectize</a>
and <a href="https://refreshless.com/nouislider/">noUiSlider</a>.
Please note that the versions bundled with DT are currently quite old,
so accepted settings may not match their most recent documentation.
</p>
</li>
<li>
<p> These settings can override values set by DT, so specifying
a setting already in use may break something. Use with care.
</p>
</li>
</ul>
</li>
</ol>
<h3>Note</h3>

<p>You are recommended to escape the table content for security reasons
(e.g. XSS attacks) when using this function in Shiny or any other dynamic
web applications.
</p>


<h3>References</h3>

<p>See <a href="https://rstudio.github.io/DT/">https://rstudio.github.io/DT/</a> for the full
documentation.
</p>


<h3>Examples</h3>

<pre><code class="language-R">library(DT)

# see the package vignette for examples and the link to website
vignette('DT', package = 'DT')

# some boring edge cases for testing purposes
m = matrix(nrow = 0, ncol = 5, dimnames = list(NULL, letters[1:5]))
datatable(m)  # zero rows
datatable(as.data.frame(m))

m = matrix(1, dimnames = list(NULL, 'a'))
datatable(m)  # one row and one column
datatable(as.data.frame(m))

m = data.frame(a = 1, b = 2, c = 3)
datatable(m)
datatable(as.matrix(m))

# dates
datatable(data.frame(
  date = seq(as.Date("2015-01-01"), by = "day", length.out = 5), x = 1:5
))
datatable(data.frame(x = Sys.Date()))
datatable(data.frame(x = Sys.time()))
</code></pre>


</div>